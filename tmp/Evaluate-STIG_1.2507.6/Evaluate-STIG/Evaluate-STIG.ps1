# ###############################################################
# # Title:        Evaluate-STIG
# # Version:      1.2507.6
# # Description:  Automates STIG compliance validation
# # Date:         11/12/2025
# ###############################################################

#requires -version 5.1

<#
    .Synopsis
        Automatically creates STIG checklists (CKL).
    .DESCRIPTION
        Automates the documentation of STIG compliance into STIG Viewer compatible checklist (.ckl) files.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1

        Runs Evaluate-STIG with default settings ("Unclassified" ScanType, "DEFAULT" Answer Key, and output to C:\Users\Public\Public Documents)
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ScanType Classified -AnswerKey TestNetwork

        Runs Evaluate-STIG for a classified system and instructs it to use the user defined "TestNetwork" Answer Key.  Refer to documentation on answer keys.
    .EXAMPLE
        PS C:\> $Result = .\Evaluate-STIG.ps1

        Runs Evaluate-STIG for an unclassified asset using the DEFAULT answer key and returns the results into a variable named "Result".
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ScanType Classified -ComputerName Workstation1

        Executes Classified scan on remote computer Workstation1.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ComputerName Workstation1,Workstation2,C:\Computers.txt -AltCredential -ThrottleLimit 7

        Executes Unclassifed scan on multiple computer names and a list of computers using an alternate credential and limiting concurrent scans to 7.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -SelectSTIG MSEdge,Chrome,Win10

        Selects Microsoft Edge, Google Chrome, and Windows 10 (by shortname) to be scanned.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ExcludeSTIG DotNET4,WinServer2019

        Excludes .NET 4 Framework and Windows Server 2019 from scan.  All other STIGs will be scanned if applicable.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -CiscoConfig C:\ShowTechFiles -ThrottleLimit 5 -VulnTimeout 5

        Recursively looks for supported Cisco show tech files in C:\ShowTechFiles, concurrently scans a maximum of 5 files at a time, and a 5 minute timeout for each Group ID.
    .INPUTS
        -ScanType <"Unclassified"|"Classified">
        Use to instruct Evaluate-STIG the classification of the asset.  Valid ScanTypes are "Unclassified" and "Classified".  If not specified, default will be "Unclassified".

        -Marking <String>
        Use to optionally set Marking in CKL/CKLB and on header/footer of files generated by Evaluate-STIG.  Example use is "CUI"/"Confidential"/"Secret"/"Top Secret" but accepts any marking string.

        -TargetComments <String>
        Use to optionally set the Target Comments field in CKL|CKLB outputs.

        -VulnTimeout <Int16>
        Maximum time in minutes to allow a singular Group ID check to run.  Default is 15.

        -FileSearchTimeout <Int16>
        Maximum time in minutes (1-1440) for file type search run during prescan.  Default is 240.  This is for checks requiring that all hard disks be searched for specific file types (e.g. .pfx).

        -AnswerKey <String>
        Use to instruct Evaluate-STIG which Answer Key to use for determining if a comment from an answer file should be applied.  Answer Keys are per Group ID and user-defined within the answer file.  If not specified, default Answer Key will be "DEFAULT".  Refer to documentation for more information.

        -AFPath <string>
        Path to Answer Files.  If not specified, defaults to $PsScriptRoot\AnswerFiles.

        -Output <"Console"|"CKL"|"CKLB"|"CSV"|"XCCDF"|"CombinedCKL"|"CombinedCKLB"|"CombinedCSV"|"OQE"|"Summary"|"STIGManager"|"Splunk">
        Specify output type(s).  Use comma separation for multiple.  If not specified, output will be returned to console.

        -JSON
        Output Console Object in JSON Format using OutputPayload Options.  JSON Objects are based on Group ID.  Requires -Output Console.

        -OutputPayload <"Title"|"Version"|"ReleaseDate"|"Classification"|"HostName"|"Site"|"Instance"|"IP"|"MAC"|"FQDN"|"Role"|"GroupID"|"GroupTitle"|"RuleID"|"STIGID"|"Severity"|"SeverityOverride"|"Justification"|"LegacyIDs"|"RuleTitle"|"Discussion"|"CheckText"|"FixText"|"CCI"|"Status"|"FindingDetails"|"Comments|"ESVersion"|"StartTime">
        Specify which fields to output when outputing to CSV, JSON, or Splunk.  Order of fields will be retained from command line.  For multiple, separate with commas.  Default is all fields.  Requires -Output CSV|CombinedCSV|Splunk or -JSON.

        -OutputPath <String>
        Sets the directory path for Evaluate-STIG to save output to (excluding STIGManager and Splunk).  Requires -Output.  May be a local or UNC path.  If not specified, default path will be C:\Users\Public\Public Documents or \opt\.  If using -OutputPath with -ComputerName, ensure the host computer's account has write access to the path in -OutputPath.

        -PreviousToKeep <Int16>
        Number of previous scan results to retain.  Default is 1.  Requires -Output.

        -AllowDeprecated
        Enable scanning of STIGs that are no longer available on cyber.mil (deprecated).  By default, deprecated STIGs will not be scanned.

        -AllowSeverityOverride
        Enables the use of the Severity Override and Justification fields in checklists.

        -AllowIntegrityViolations
        Ignores Evaluate-STIG file integrity validation failures and allows the scan to continue.

        -SelectSTIG <String>
        Specify which STIG(s) to scan.  Use Tab or CTRL+SPACE to properly select STIG(s) by its short name.  For deprecated STIGs, must call -AllowDeprecated first.  For multiple STIGs, separate with commas.  Cannot be specified with -ExcludeSTIG.

        -ExcludeSTIG <String>
        Specify which STIG(s) to exclude from the scan.  Use Tab or CTRL+SPACE to properly exclude STIG(s) by its short name.  For multiple STIGs, separate with commas.  Cannot be specified with -SelectSTIG.

        -ForceSTIG <String>
        Ignore detection of STIG applicability and forcefully run a scan of selected STIG(s).  Use Tab or CTRL+SPACE to properly select STIG(s) by its short name.  For multiple STIGs, separate with commas.  *WARNING* Evaluate-STIG results are not guaranteed with this option.  Use at own risk. *WARNING*

        -SelectVuln <String>
        Specify which Group ID(s) to scan (V-#####).  For multiple, separate with commas.  Can only be used with -SelectSTIG.

        -ExcludeVuln <String>
        Specify which Group ID(s) to exclude from a scan (V-#####).  For multiple, separate with commas.  Can only be used with -SelectSTIG.

        -ComputerName <String>
        Execute scan on remote computer.  Supports multiple computers through comma separation. Can be a computer name, a file with a list of computers, or a combination.  By default, results will be copied back to source computer.  Requires admin rights on remote computer.

        -CiscoConfig <String>
        Execute a scan of Cisco show tech files.  May be a path to a single file, a folder, or combination using comma separation.

        -SelectDeviceType
        Specify a device type for IOS, IOS-XE Catalyst 9k series, and IOS-XE ISR device specific Cisco configs. Use comma separation for multiple.  Requires -CiscoConfig.

        -ThrottleLimit <Int16>
        Number of concurrent Evaluate-STIG jobs to run when using -ComputerName or -CiscoConfig.  Default is 10. Requires -ComputerName or -CiscoConfig.

        -AltCredential
        Prompts for an alternate credential to use for remote scans.  If connection to the remote machine fails with the alternate credential, Evaluate-STIG will fallback to the launching user and attempt the connection - essentially allowing for two credentials to be used for remote scan (e.g. workstation/server credentials).  Requires -ComputerName input.  Windows only.

        -SMCollection <String>
        Use to instruct Evaluate-STIG which STIGManager Collection to upload results.  Requires -Output STIGManager.

        -SMPassphrase <String>
        Passphrase to decrpyt private key if encrypted .key is used for authentication to a STIGManager instance.  Requires -Output STIGManager.

        -SplunkHECName <String>
        Use to direct Evaluate-STIG which configured Splunk HTTP Event Collection (HEC) to upload results.  Requires -Output Splunk.

        -ApplyTattoo
        Applies Evaluate-STIG tattooing on system.  Mainly for providing a detection method to configuration management tools.

        -ListSupportedProducts
        Lists all products that Evaluate-STIG currently supports.

        -ListApplicableProducts
        Lists all Evaluate-STIG supported STIGs that are applicable to the asset.

        -Version
        Display Evaluate-STIG version and running path.

        -Update
        Downloads updates to Evaluate-STIG from the Evaluate-STIG repo on SPORK.

        -LocalSource
        Directs -Update to download updates to Evaluate-STIG from a local Evaluate-STIG directory.

        -Proxy <String>
        Configure proxy for use with -Update.
    .LINK
        Evaluate-STIG
        https://spork.navsea.navy.mil/nswc-crane-division/evaluate-stig
        https://intelshare.intelink.gov/sites/NAVSEA-RMF

        Windows Remote Management (WinRM)
        https://docs.microsoft.com/en-us/windows/win32/winrm

        CMTrace (for viewing EValuate-STIG.log)
        https://docs.microsoft/en-us/configmgr/core/support/cmtrace
    #>

[CmdletBinding(PositionalBinding = $false)]
Param (
    [Parameter(Mandatory = $false)]
    [String[]]$ComputerName,

    [Parameter(Mandatory = $false)]
    [String[]]$CiscoConfig,

    # TODO: Staging VMWare Content
    # TODO: Need to require -VCenterApplianceName for -VMName, but do NOT need the inverse.
    #[Parameter(Mandatory = $false)]
    #[String[]]$VCenterApplianceName,

    #[Parameter(Mandatory = $false)]
    #[String[]]$VMName,

    [Parameter(Mandatory = $false)]
    [ValidateSet("Unclassified", "Classified")]
    [String]$ScanType = "Unclassified",

    [Parameter(Mandatory = $false)]
    [String]$Marking,

    [Parameter(Mandatory = $false)]
    [String]$TargetComments,

    [Parameter(Mandatory = $false)]
    [ValidateRange(1, 1440)]
    [Int16]$VulnTimeout = 15,

    [Parameter(Mandatory = $false)]
    [ValidateRange(1, 1440)]
    [Int16]$FileSearchTimeout = 240,

    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [String]$AFPath,

    [Parameter(Mandatory = $false)]
    [String]$AnswerKey = "DEFAULT",

    # Code for -Output Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assit in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            $ValidValues = @("Console", "CKL", "CKLB", "CSV", "XCCDF", "CombinedCKL", "CombinedCKLB", "CombinedCSV", "OQE", "Summary", "STIGManager", "Splunk")
            $ValidValues | Where-Object { $_ -like "$WordToComplete*" }
        })]
    [ValidateScript({
            $ValidValues = @("Console", "CKL", "CKLB", "CSV", "XCCDF", "CombinedCKL", "CombinedCKLB", "CombinedCSV", "OQE", "Summary", "STIGManager", "Splunk")
            ForEach ($Value in ($_ -split ",")) {
                If ($Value -notin $ValidValues) {
                    Throw "`r`n `r`n'$_' is not a valid Output.  Valid Output entries include $($ValidValues -join ", ")`r`n `r`n"
                }
            }
            $true
        })]
    [String[]]$Output = "Console",

    [Parameter(Mandatory = $false)]
    [Switch]$ApplyTattoo,

    [Parameter(Mandatory = $false)]
    [Switch]$ListApplicableProducts,

    [Parameter(Mandatory = $false)]
    [Switch]$ListSupportedProducts,

    [Parameter(Mandatory = $false)]
    [Switch]$AllowDeprecated,

    [Parameter(Mandatory = $false)]
    [Switch]$AllowSeverityOverride,

    [Parameter(Mandatory = $false)]
    [Switch]$AllowIntegrityViolations,

    [Parameter(Mandatory = $false)]
    [Switch]$Version,

    [Parameter(Mandatory = $false)]
    [Switch]$Update,

    # Code for -SelectSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                if ($CommandAst.Parent.PipeLineElements -match "CiscoConfig") {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -EQ "Cisco"
                }
                else {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -NE "Cisco"
                }

                If ($CommandAst.Parent.PipeLineElements -match "-AllowDeprecated") {
                    $STIGs = $PlatformSTIGs | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }
                Else {
                    $STIGs = $PlatformSTIGs | Where-Object DisaStatus -NE "Deprecated" | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }
                Foreach ($ManualSTIG in $((Get-ChildItem $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath "Manual") | Where-Object Extension -eq ".xml"))) {
                    [xml]$Content = Get-Content $ManualSTIG.FullName
                    $STIGName = $Content.Benchmark.ID
                    $STIGs += [PSCustomObject]@{
                        Name = $STIGName
                        Shortname = "M_" + $($STIGName -replace "_", "" -replace "STIG", "")
                    }
                }

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript({
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            $PrefsXML = Join-Path $PsScriptRoot -ChildPath "Preferences.xml"
            If (Test-Path $STIGListXML) {
                if ($PSBoundParameters.Keys -contains "CiscoConfig") {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -EQ "Cisco"
                }
                Else {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -NE "Cisco"
                }

                $ValidSTIGs = ($PlatformSTIGs | Where-Object DisaStatus -NE "Deprecated").ShortName
                foreach ($ManualSTIG in $((Get-ChildItem $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath "Manual") | Where-Object Extension -EQ ".xml"))) {
                    [xml]$Content = Get-Content $ManualSTIG.FullName
                    $STIGName = $Content.Benchmark.ID
                    $ValidSTIGs += "M_" + $($STIGName -replace "_", "" -replace "STIG", "")
                }
                $DeprecatedSTIGs = ($PlatformSTIGs | Where-Object DisaStatus -EQ "Deprecated").ShortName
                If (Test-Path $PrefsXML) {
                    Try {
                        $PrefAllowDep = ((Select-Xml -Path $PrefsXML -XPath "/" | Select-Object -ExpandProperty Node).Preferences.EvaluateSTIG.AllowDeprecated).Trim()
                    }
                    Catch {
                        Throw "`r`n `r`nPreferences.xml cannot be read.  Cannot continue.`r`n `r`n"
                    }
                }
                $_ -Split "," | ForEach-Object {
                    If (($_ -in $ValidSTIGs) -or ($_ -in $DeprecatedSTIGs -and ($PSBoundParameters.Keys -contains "AllowDeprecated" -or $PrefAllowDep -eq "true"))) {
                        $true
                    }
                    ElseIf ($DeprecatedSTIGs -contains $_) {
                        Throw "`r`n `r`n'$_' is a deprecated STIG.  Please use '-AllowDeprecated' to enable deprecated STIG scans.`r`n `r`n"
                    }
                    Else {
                        Throw "`r`n `r`n'$_' is either not a product supported by Evaluate-STIG or not supported in this context.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$SelectSTIG,

    # Code for -ExcludeSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                if ($CommandAst.Parent.PipeLineElements -match "CiscoConfig") {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -EQ "Cisco" | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }
                else {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -NE "Cisco" | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }

                # Compose CompletionResult Entries
                $PlatformSTIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript( {
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                if ($PSBoundParameters.Keys -contains "CiscoConfig") {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -EQ "Cisco"
                }
                else {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -NE "Cisco"
                }
                $ValidSTIGs = ($PlatformSTIGs).ShortName
                $_ -Split "," | ForEach-Object {
                    If ($_ -in $ValidSTIGs) {
                        $true
                    }
                    Else {
                        throw "`r`n `r`n'$_' is either not a product supported by Evaluate-STIG or not supported in this context.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$ExcludeSTIG,

    # Code for -ForceSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                if ($CommandAst.Parent.PipeLineElements -match "CiscoConfig") {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -EQ "Cisco"
                }
                else {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -NE "Cisco"
                }
                $STIGs = $PlatformSTIGs | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                foreach ($ManualSTIG in $((Get-ChildItem $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath "Manual") | Where-Object Extension -EQ ".xml"))) {
                    [xml]$Content = Get-Content $ManualSTIG.FullName
                    $STIGName = $Content.Benchmark.ID
                    $STIGs += [PSCustomObject]@{
                        Name = $STIGName
                        Shortname = "M_" + $($STIGName -replace "_", "" -replace "STIG", "")
                    }
                }

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript({
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                if ($PSBoundParameters.Keys -contains "CiscoConfig") {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -EQ "Cisco"
                }
                else {
                    $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -NE "Cisco"
                }
                $ValidSTIGs = ($PlatformSTIGs).ShortName
                foreach ($ManualSTIG in $((Get-ChildItem $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath "Manual") | Where-Object Extension -EQ ".xml"))) {
                    [xml]$Content = Get-Content $ManualSTIG.FullName
                    $STIGName = $Content.Benchmark.ID
                    $ValidSTIGs += "M_" + $($STIGName -replace "_", "" -replace "STIG", "")
                }
                $_ -Split "," | ForEach-Object {
                    If ($_ -in $ValidSTIGs) {
                        $true
                    }
                    Else {
                        throw "`r`n `r`n'$_' is either not a product supported by Evaluate-STIG or not supported in this context.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$ForceSTIG
)

# Expose additional dynamic parameters
DynamicParam {

    # Helper Function
    Function New-RuntimeDefinedParameter {
        [cmdletbinding()]
        [Alias('New-RDP')]
        param (
            [Parameter(Mandatory)]
            [Alias('Name')]
            [string]$ParameterName,

            [type]$Type         = [string],
            [bool]$Mandatory    = $false,
            [Attribute[]]$Extra = @() # e.g. [ValidateSet]
        )
        $AttributesCollection = [System.Collections.ObjectModel.Collection[System.Attribute]]::new()

        $Attribute = [System.Management.Automation.ParameterAttribute]@{ Mandatory = $Mandatory }
        $AttributesCollection.Add($Attribute)

        Foreach ($attr in $Extra) { $AttributesCollection.Add($attr) }

        $RuntimeParameter = [System.Management.Automation.RuntimeDefinedParameter]::new(
            $ParameterName,
            $Type,
            $AttributesCollection
        )

        return $RuntimeParameter
    } # END FUNCTION New-RuntimeDefinedParameter

    # Initialize variables
    $ParameterDictionary = [System.Management.Automation.RuntimeDefinedParameterDictionary]::new()

    # Parameters related to remote capabilities
    $needsRemote = ($ComputerName -and -not $IsLinux) -or
        $CiscoConfig -or $VCenterApplianceName -or $VMName
    if ($needsRemote) {
        If ($ComputerName -or ($VCenterApplianceName -or $VMName)) {
            # Expose -AltCredential if -ComputerName is specified
            $ParameterDictionary.Add('AltCredential', (New-RDP -Name 'AltCredential' -Type ([switch])))
        }

        # Expose -ThrottleLimit
        $ParameterDictionary.Add('ThrottleLimit', (New-RDP -Name 'ThrottleLimit' -Type ([Int16])))
    }

    # Parameters related to -Update
    If ($Update) {
        # Expose -Proxy, -LocalSource
        $ParameterDictionary.Add('Proxy', (New-RDP -Name 'Proxy'))
        $ParameterDictionary.Add('LocalSource', (New-RDP -Name 'LocalSource'))
    }

    # Parameters related to -Output
    If ($Output) {
        $tokens = ($Output -split ',').Trim()

        # Expose -OutputPath & -PreviousToKeep if CKL/CSV/XCCDF/....
        If ($tokens -match '^(CKL(B)?|CSV|XCCDF|CombinedCKL(B)?|CombinedCSV|Summary|OQE)$') {
            $ParameterDictionary.Add('OutputPath', (New-RDP -Name 'OutputPath'))
            $ParameterDictionary.Add('PreviousToKeep', (New-RDP -Name 'PreviousToKeep' -Type ([int16])))
        }

        # Expose STIGManager-related parameters
        If ($tokens -contains 'STIGManager') {
            $ParameterDictionary.Add('SMPassphrase', (New-RDP -Name 'SMPassphrase'))
            $ParameterDictionary.Add('SMCollection', (New-RDP -Name 'SMCollection'))# -Mandatory))
        }

        # Expose Splunk-related parameters
        If ($tokens -contains 'Splunk') {
            $ParameterDictionary.Add('SplunkHECName', (New-RDP -Name 'SplunkHECName'))
        }

        # Expose Console-related parameters
        If ($tokens -contains 'Console') {
            $ParameterDictionary.Add('JSON', (New-RDP -Name 'JSON' -Type ([switch])))
        }

        # Expose -OutputPayLoad
        # NOTE: Ideally we want -OutputPayLoad only exposed for CSV/CombinedCSV/Splunk OR "-Output Console -JSON". It's not really possible to assess if a DynamicParameter exists within the DynamicParam block..... So if "-Output Console" and then check for -JSON (if -OutputPayLoad) in begin{}.
        $needsOutputPayLoad = ($tokens -match '^(CSV|CombinedCSV|Splunk)$') -or
        ($tokens -contains 'Console')
        if ($needsOutputPayLoad) {

            # Handle ValidateScript: ensure every provided token is in the allowlist
            $ValSB_ScriptBlock = {
                $validPayload = @(
                    'Title', 'Version', 'ReleaseDate', 'Classification', 'HostName', 'Site',
                    'Instance', 'IP', 'MAC', 'FQDN', 'Role', 'GroupID', 'GroupTitle', 'RuleID',
                    'STIGID', 'Severity', 'SeverityOverride', 'Justification', 'LegacyIDs',
                    'RuleTitle', 'Discussion', 'CheckText', 'FixText', 'CCI', 'Status',
                    'FindingDetails', 'Comments', 'ESVersion', 'StartTime'
                )
                foreach ($Value in ($_ -split ',')) {
                    if ($Value -notin $validPayload) {
                        throw "`r`n `r`n'$_' is not a valid Output.  Valid OutputPayLoad entries include $($validPayload -join ", ")`r`n `r`n"
                    }
                }
                $true
            }
            $ValSBAttr = [System.Management.Automation.ValidateScriptAttribute]::new($ValSB_ScriptBlock)

            # ArgumentCompleter: suggest remaining items, honoring what is already typed
            $AC_ScriptBlock = {
                # Recieve information about current state to assist in auto-completing user typed value
                param($cmdName, $paramName, $wordToComplete, $commandAst, $fakeBoundParams)

                $validPayload = @(
                    'Title', 'Version', 'ReleaseDate', 'Classification', 'HostName', 'Site',
                    'Instance', 'IP', 'MAC', 'FQDN', 'Role', 'GroupID', 'GroupTitle', 'RuleID',
                    'STIGID', 'Severity', 'SeverityOverride', 'Justification', 'LegacyIDs',
                    'RuleTitle', 'Discussion', 'CheckText', 'FixText', 'CCI', 'Status',
                    'FindingDetails', 'Comments', 'ESVersion', 'StartTime'
                )

                $validPayload | Where-Object { $_ -like "$WordToComplete*" }
            }
            $ACAttr = [System.Management.Automation.ArgumentCompleterAttribute]::new($AC_ScriptBlock)

            $ParameterDictionary.Add(
                'OutputPayLoad',
                (New-RDP -Name 'OutputPayLoad' -Type ([string[]]) -Extra @($ValSBAttr, $ACAttr))
            )
        }
    }

    # Parameters related to -SelectSTIG
    If ($SelectSTIG) {
        $ParameterDictionary.Add('SelectVuln', (New-RDP -Name 'SelectVuln' -Type ([array])))
        $ParameterDictionary.Add('ExcludeVuln', (New-RDP -Name 'ExcludeVuln' -Type ([array])))
    }

    # Parameters related to -Output
    if ($CiscoConfig) {
        # Expose -SelectDeviceType
        # Handle ValidateScript: ensure every provided token is in the allowlist
        $ValSB_ScriptBlock = {
            $validTypes = @('Router', 'Switch')
            foreach ($Value in ($_ -split ',')) {
                if ($Value -notin $validTypes) {
                    throw "`r`n `r`n'$_' is not a valid device type.  Valid SelectDeviceType entries include $($validTypes -join ", ")`r`n `r`n"
                }
            }
            $true
        }
        $ValSBAttr = [System.Management.Automation.ValidateScriptAttribute]::new($ValSB_ScriptBlock)

        # ArgumentCompleter: suggest remaining items, honoring what is already typed
        $AC_ScriptBlock = {
            # Recieve information about current state to assist in auto-completing user typed value
            param($cmdName, $paramName, $wordToComplete, $commandAst, $fakeBoundParams)

            $validTypes = @('Router', 'Switch')

            $validTypes | Where-Object { $_ -like "$WordToComplete*" }
        }
        $ACAttr = [System.Management.Automation.ArgumentCompleterAttribute]::new($AC_ScriptBlock)

        $ParameterDictionary.Add(
            'SelectDeviceType',
            (New-RDP -Name 'SelectDeviceType' -Type ([string[]]) -Extra @($ValSBAttr, $ACAttr))
        )
    }

    Return $ParameterDictionary
}

Process {
    Try {
        # Initialize ExitCode variable
        $ExitCode = 0

        # Just a blank line in console for readability
        Write-Host ""

        # -Update and external scripts reference the below $EvaluateStigVersion line as written.  Do not modify.
        $EvaluateStigVersion = "1.2507.6"

        # Collect dynamic / prepare array parameters
        If ($ComputerName) {
            $ComputerName = $ComputerName -Split ","
        }
        If ($CiscoConfig) {
            $CiscoConfig = $CiscoConfig -Split ","
        }
        If ($Output) {
            $Output = $Output -Split ","
        }
        If ($SelectSTIG) {
            $SelectSTIG = $SelectSTIG -Split ","
        }
        If ($ExcludeSTIG) {
            $ExcludeSTIG = $ExcludeSTIG -Split ","
        }
        If ($ForceSTIG) {
            $ForceSTIG = $ForceSTIG -Split ","
        }
        If ($PsBoundParameters.OutputPath) {
            $OutputPath = $PsBoundParameters.OutputPath
        }
        If ("PreviousToKeep" -in $PsBoundParameters.Keys) {
            $PreviousToKeep = $PsBoundParameters.PreviousToKeep
        }
        Else {
            $PreviousToKeep = 1
        }
        If ($PsBoundParameters.AltCredential) {
            $AltCredential = "{0}" -f $PsBoundParameters.AltCredential
        }
        If ($PsBoundParameters.SelectVuln) {
            $SelectVuln = ($PsBoundParameters.SelectVuln -Split ",").Trim() | Sort-Object -Unique
        }
        If ($PsBoundParameters.ExcludeVuln) {
            $ExcludeVuln = ($PsBoundParameters.ExcludeVuln -Split ",").Trim() | Sort-Object -Unique
        }
        If ($PsBoundParameters.OutputPayload) {
            $OutputPayload = ($PsBoundParameters.OutputPayload -Split ",").Trim() | Select-Object -Unique
        }
        If ($PsBoundParameters.ThrottleLimit) {
            $ThrottleLimit = $PsBoundParameters.ThrottleLimit
        }
        If ($PSBoundParameters.SMPassphrase) {
            $SMPassphrase = $PsBoundParameters.SMPassphrase | ConvertTo-SecureString -AsPlainText -Force
        }
        If ($PSBoundParameters.SMCollection) {
            $SMCollection = $PsBoundParameters.SMCollection
        }
        If ($PSBoundParameters.SplunkHECName) {
            $SplunkHECName = $PsBoundParameters.SplunkHECName
        }
        If ($PSBoundParameters.JSON) {
            $JSON = $PsBoundParameters.JSON
        }
        if ($PSBoundParameters.SelectDeviceType) {
            $SelectDeviceType = $PsBoundParameters.SelectDeviceType
        }
        # Special-handle for -OutputPayLoad and validating it properly
        If ($OutputPayLoad) {
            $needsOutputPayLoad = ($tokens -match '^(CSV|CombinedCSV|Splunk)$') -or $JSON
            If (-not $needsOutputPayLoad) {
                throw '-OutputPayLoad was specified but should not have been.'
            }
        }

        # ---------- Begin Prechecks ----------
        If (-Not($IsLinux)) {
            # Check for blocked files and instruct to run Test-Prerequisites.bat to correct.  This can result in prompts to load each module.
            $FileBlock = $false
            $Content = Get-ChildItem $PSScriptRoot -Recurse
            ForEach ($Item in $Content) {
                If (Get-Item $Item.FullName -Stream * -ErrorAction SilentlyContinue | Where-Object Stream -eq Zone.Identifier) {
                    $FileBlock = $true
                    Break
                }
            }

            If ($FileBlock -eq $true) {
                Write-Host "File detected with the block attribute set.  Please run Test-Prerequisites.bat to correct." -ForegroundColor Yellow
            }
        }

        # Get PowerShell version and OS platform (Linux or Windows).  If unsupported detected, fail out.
        $PowerShellVersion = $PsVersionTable.PSVersion
        If ($PowerShellVersion -ge [Version]"7.0") {
            If ($PowerShellVersion -ge [Version]"7.2") {
                $PSStyleBackup = @{
                    ProgressView    = $PSStyle.Progress.View
                    OutputRendering = $PSStyle.OutputRendering
                }
                $PSStyle.Progress.View = "Classic"
                $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::PlainText
            }
            If ($IsLinux -eq $true) {
                $Global:OSPlatform = "Linux"
            }
            If ($IsWindows -eq $true) {
                $Global:OSPlatform = "Windows"
                [Version]$WMFVersion = (PowerShell.exe -NoProfile -Command {$PsVersionTable}).PsVersion
                If ($WMFVersion -lt [Version]"5.1") {
                    $ExitCode = 1
                    Throw "Windows Management Framework (WMF) $($WMFVersion -join '.') detected.  WMF 5.1 or greater is required."
                }
            }
        }
        ElseIf ($PowerShellVersion -lt [Version]"5.1" -or ($PowerShellVersion -join "." -like "7.*" -and $PowerShellVersion -lt [Version]"7.3") -or ($PowerShellVersion -join "." -like "6.*")) {
            $ExitCode = 1
            Throw "PowerShell $($PowerShellVersion -join '.') detected.  Evaluate-STIG only supports PowerShell 5.1 or PowerShell 7.3 and greater.  PowerShell 6.x is not supported."
        }
        Else {
            $Global:OSPlatform = "Windows"
        }

        # Import required modules
        If (Test-Path (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions")) {
            If ($PowerShellVersion -lt [Version]"7.0") {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -ErrorAction Stop
            }
            Else {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -SkipEditionCheck -ErrorAction Stop
            }
        }
        Else {
            $ExitCode = 2
            Throw "'Master_Functions' module not found.  Unable to continue."
        }

        # If -ListApplicableProducts, -ListSupportedProducts, or -Version are specified and not the only param specified, error out.
        If (($PsBoundParameters.Keys | Measure-Object).Count -gt 1) {
            ForEach ($Key in $PsBoundParameters.Keys) {
                If ($Key -in @("ListSupportedProducts", "Version")) {
                    $ExitCode = 1
                    Throw "-$Key must not have additional parameters specified."
                }
                ElseIf ($Key -eq "ListApplicableProducts" -and $PsBoundParameters.Keys -notcontains "AllowDeprecated") {
                    $ExitCode = 1
                    Throw "Only -AllowDeprecated may be used in conjuction with-$Key."
                }
            }
        }

        # If both -ComputerName and -CiscoConfig are specified, error out.  Only one may be specified.
        If (($ComputerName) -and ($CiscoConfig -or $VCenterApplianceName)) {
            $ExitCode = 1
            Throw "-ComputerName and -CiscoConfig cannot both be specified."
            # TODO: Swap the below line IN once VCenter is supported
            #Throw "Cannot specify more than one these parameters at a time: -ComputerName, -CiscoConfig or $VCenterApplianceName."
        }

        # If both -SelectSTIG and -ExcludeSTIG are specified, error out.  Only one may be specified.
        If (($SelectSTIG) -and ($ExcludeSTIG)) {
            $ExitCode = 1
            Throw "-SelectSTIG and -ExcludeSTIG cannot both be specified."
        }

        # Confirm -SelectVuln/-ExcludeVuln are properly formatted
        If ($SelectVuln) {
            ForEach ($Item in $SelectVuln) {
                If ($Item -notmatch "^V-\d{4,6}$") {
                    $ExitCode = 1
                    Throw "$Item is an invalid entry for -SelectVuln.  Must be V-####."
                }
            }
        }
        ElseIf ($ExcludeVuln) {
            ForEach ($Item in $ExcludeVuln) {
                If ($Item -notmatch "^V-\d{4,6}$") {
                    $ExitCode = 1
                    Throw "$Item is an invalid entry for -ExcludeVuln.  Must be V-####."
                }
            }
        }
        # ---------- End Prechecks ----------

        # ---------- Begin Utility Parameters ----------
        # If -ListSupportedSTIGs specified, display list and exit.
        If ($ListSupportedProducts) {
            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $XmlFile = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                $ExitCode = 2
                Throw "'$Xmlfile' file not found.  Please update with -Update option."
            }
            ElseIf (-Not(Test-Path $STIGList_xsd)) {
                $ExitCode = 2
                Throw "'$STIGList_xsd' file not found.  Please update with -Update option."
            }
            ElseIf ((Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd) -ne $true) {
                $ExitCode = 1
                Throw "'$Xmlfile' failed schema validation.  Please update with -Update option."
            }

            # Get list of supported STIGs
            $Result = (Get-SupportedProducts -ES_Path $PsScriptRoot)

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()
            Start-Sleep -Seconds 1

            Return $Result
        }

        # If -ListApplicableProducts specified, display list and exit.
        If ($ListApplicableProducts) {
            # Confirm we have an elevated session.
            Switch ($OSPlatform) {
                "Windows" {
                    If (-NOT([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator") -and !$AltCredential -and ($LinuxList.count -eq 0)) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session or use -AltCredential."
                    }
                }
                "Linux" {
                    If ((id -u) -ne 0) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session."
                    }
                }
            }

            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $XmlFile = Join-Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                $ExitCode = 2
                Throw "'$Xmlfile' file not found.  Please update with -Update option."
            }
            ElseIf (-Not(Test-Path $STIGList_xsd)) {
                $ExitCode = 2
                Throw "'$STIGList_xsd' file not found.  Please update with -Update option."
            }
            ElseIf ((Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd) -ne $true) {
                $ExitCode = 1
                Throw "'$Xmlfile' failed schema validation.  Please update with -Update option."
            }

            # Get list of applicable STIGs
            $Result = (Get-ApplicableProducts -ES_Path $PsScriptRoot -AllowDeprecated:$AllowDeprecated)

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()
            Start-Sleep -Seconds 1

            Return $Result
        }

        # If -Version specified, display its output.
        If ($Version) {
            $Result = [PSCustomObject]@{
                Version     = $EvaluateStigVersion
                RunningPath = $PSScriptRoot
            }
            Return $Result
        }

        # If -Update specified, download the latest updates.
        If ($Update) {
            Try {
                # Linux requires elevation
                If ($IsLinux) {
                    # Confirm we have an elevated session.
                    If ((id -u) -ne 0) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session."
                    }
                }

                If ($PSBoundParameters.LocalSource) {
                    $LocalSource = $PSBoundParameters.LocalSource
                }

                If ($PSBoundParameters.Proxy) {
                    $Proxy = $PSBoundParameters.Proxy
                }

                Get-FileUpdatesFromRepo -PS_Path $PsScriptRoot -Proxy $Proxy -LocalSource $LocalSource

                If ($PSStyleBackup) {
                    # Restore $PSStyle settings
                    $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                    $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
                }

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
                [System.GC]::Collect()
                Start-Sleep -Seconds 1

                Exit $ExitCode
            }
            Catch {
                $ExitCode = 1
                Throw $_
            }
        }
        # ---------- End Utility Parameters ----------

        # Read in Preferences.xml and set parameters if not called from command line
        $Preferences_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_Preferences.xsd"
        $Preferences_xml = Join-Path -Path $PsScriptRoot -ChildPath "Preferences.xml"
        If (Test-Path $Preferences_xml) {
            $ParameterList = (Get-Command -Name (Join-Path $PsScriptRoot -ChildPath ($MyInvocation.MyCommand))).Parameters

            # Validate Preferences.xml against schema
            If (-Not(Test-Path $Preferences_xsd)) {
                $ExitCode = 2
                Throw "'$Preferences_xsd' file not found.  Please update with -Update option."
            }
            Else {
                $Valid = Test-XmlValidation -XmlFile $Preferences_xml -SchemaFile $Preferences_xsd
                If ($Valid -ne $true) {
                    $Msg = "'$Preferences_xml' failed schema validation." | Out-String
                    $Msg += $Valid.Message | Out-String
                    $ExitCode = 1
                    Throw $Msg
                }
            }

            # Set parameters defined in Preferences.xml.  Parameters called from command line override Preferences.xml
            $Preferences = (Select-Xml -Path $Preferences_xml -XPath /).Node
            $InUsePrefs = New-Object System.Collections.Generic.List[System.Object]
            ForEach ($Item in ($Preferences.Preferences.EvaluateSTIG | Get-Member -MemberType Property | Where-Object Name -NE '#comment').Name) {
                If ($Preferences.Preferences.EvaluateSTIG.$Item -ne '' -and (-Not($Item -in $PSBoundParameters.Keys))) {
                    $InUsePrefs.Add($Item)
                    # Prerequisite param must be verified before setting dynamic param
                    Switch ($Item) {
                        "ExcludeSTIG" {
                            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
                            If ($PSBoundParameters.Keys -contains "CiscoConfig") {
                                $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -EQ "Cisco"
                            }
                            Else {
                                $PlatformSTIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object AssetType -NE "Cisco"
                            }

                            $ExcludedSTIGs = @()
                            ForEach ($STIG in ($Preferences.Preferences.EvaluateSTIG.$Item -split ",")) {
                                if ($STIG -in $PlatformSTIGs.ShortName) {
                                    $ExcludedSTIGs += $STIG
                                }
                            }

                            if (($ExcludedSTIGs | Measure-Object).Count -ge 1) {
                                Set-Variable -Name $Item -Value $([String[]]$ExcludedSTIGs)
                            }
                        }
                        "ExcludeVuln" {
                            $Prereq = @("SelectSTIG")
                            ForEach ($obj in $Prereq) {
                                # Dynamic parameters must be added to $PSBoundParameters
                                If ($PSBoundParameters.Keys -contains $obj) {
                                    $PSBoundParameters.Add($Item, $($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", ''))
                                    Break
                                }
                            }
                        }
                        "JSON" {
                            Set-Variable -Name $Item -Value $([System.Convert]::ToBoolean($($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')))
                        }
                        DEFAULT {
                            # Static parameters must have their variable set
                            Try {
                                If ($ParameterList[$Item].ParameterType.Name -eq "SwitchParameter") {
                                    Set-Variable -Name $Item -Value $([System.Convert]::ToBoolean($($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')))
                                }
                                ElseIf ($ParameterList[$Item].ParameterType.Name -eq "String[]") {
                                    Set-Variable -Name $Item -Value $([String[]]$Preferences.Preferences.EvaluateSTIG.$Item -Split ",")
                                }
                                ElseIf ($ParameterList[$Item].ParameterType.Name -eq "Array") {
                                    Set-Variable -Name $Item -Value $([String[]]$Preferences.Preferences.EvaluateSTIG.$Item -Split ",")
                                }
                                Else {
                                    Set-Variable -Name $Item -Value $($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')
                                }
                            }
                            Catch {
                                $Msg = "Invalid entry in Preferences.xml for '$Item'" | Out-String
                                If ((Get-Variable $Item -ErrorAction SilentlyContinue).Attributes.ValidValues) {
                                    $Msg += "Valid values include $((Get-Variable $Item).Attributes.ValidValues -join ', ')" | Out-String
                                }
                                $Msg += $_.Exception.Message | Out-String
                                $ExitCode = 1
                                Throw $Msg
                            }
                        }
                    }
                }
            }

            If ($SelectSTIG) {
                # ApplyTattoo must be ignored
                $ApplyTattoo = $false
            }

            If (($Output -Split ",").Trim() -match "(^CSV$|^CombinedCSV$|^Splunk$)" -or $JSON) {
                If (-Not("OutputPayload" -in $PSBoundParameters.Keys)) {
                    $InUsePayload = New-Object System.Collections.Generic.List[System.Object]
                    ForEach ($Item in ($Preferences.Preferences.OutputPayload.SelectNodes("*").LocalName)) {
                        Try {
                            if ($([System.Convert]::ToBoolean($($Preferences.Preferences.OutputPayload.$Item -replace '"', '' -replace "'", '')))) {
                                $InUsePayload.Add($Item)
                            }
                        }
                        Catch {
                            $Msg = "Invalid entry in Preferences.xml for '$Item' in <OutputPayload>" | Out-String
                            $Msg += "Valid values include 'true', 'false'" | Out-String
                            $Msg += $_.Exception.Message | Out-String
                            $ExitCode = 1
                            Throw $Msg
                        }
                    }
                    Set-Variable -Name "OutputPayload" -Value $([String[]]$InUsePayload -Split ",")
                }
            }
        }

        if (($Output -split ",").Trim() -match "(^STIGManager$)") {
            If ($PowerShellVersion -le [Version]"7.0") {
                $ExitCode = 1
                Throw "PowerShell $($PowerShellVersion -join '.') detected.  STIGManager integration requires PowerShell 7.x and greater."
            }

            ForEach ($Item in ($Preferences.Preferences.STIGManager | Get-Member -MemberType Property | Where-Object Definition -Match string | Where-Object Name -NE '#comment').Name) {
                $Preferences.Preferences.STIGManager.$Item = $Preferences.Preferences.STIGManager.$Item -replace '"', '' -replace "'", ''
            }

            #Validate STIGMan Preferences
            if (-Not($Preferences.Preferences.STIGManager.SMImport_API_BASE)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_API_BASE."
            }
            if (-Not($Preferences.Preferences.STIGManager.SMImport_AUTHORITY)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_AUTHORITY."
            }

            if ($Preferences.Preferences.STIGManager | Select-Object -ExpandProperty SMImport_COLLECTION | Where-Object Name -EQ $SMCollection) {
                $STIGManagerObject = $Preferences.Preferences.STIGManager | Select-Object -ExpandProperty SMImport_COLLECTION | Where-Object Name -EQ $SMCollection

                ForEach ($Item in ($STIGManagerObject | Get-Member -MemberType Property | Where-Object Definition -Match string).Name) {
                    $STIGManagerObject.$Item = $STIGManagerObject.$Item -replace '"', '' -replace "'", ''
                }
            }
            else {
                $ExitCode = 1
                Throw "STIGManager: $SMCollection not found or parameter missing."
            }
            if (-Not($STIGManagerObject.SMImport_CLIENT_ID)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_CLIENT_ID."
            }
            if (-Not($STIGManagerObject.SMImport_COLLECTION_ID)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_COLLECTION_ID."
            }
            If ($STIGManagerObject.SMImport_CLIENT_CERT_KEY) {
                if (Test-Path $STIGManagerObject.SMImport_CLIENT_CERT_KEY) {
                    if ($STIGManagerObject.SMImport_CLIENT_CERT_KEY -and (-Not($SMPassphrase))) {
                        $ExitCode = 1
                        Throw "STIGManager Key detected but no Passphrase was provided."
                    }
                }
                else {
                    $ExitCode = 2
                    Throw "STIGManager preferences missing SMImport_CLIENT_CERT_KEY or file not found."
                }
            }
        }

        if (($Output -split ",").Trim() -match "(^Splunk$)") {
            If ($PowerShellVersion -le [Version]"7.0") {
                $ExitCode = 1
                Throw "PowerShell $($PowerShellVersion -join '.') detected.  Splunk integration requires PowerShell 7.x and greater."
            }

            ForEach ($Item in ($Preferences.Preferences.Splunk | Get-Member -MemberType Property | Where-Object Definition -Match string | Where-Object Name -NE '#comment').Name) {
                $Preferences.Preferences.Splunk.$Item = $Preferences.Preferences.Splunk.$Item -replace '"', '' -replace "'", ''
            }

            #Validate Splunk Preferences
            if (-Not($Preferences.Preferences.Splunk.Splunk_URI)) {
                $ExitCode = 1
                Throw "Splunk preferences missing Splunk_URI."
            }
            if ($Preferences.Preferences.Splunk | Select-Object -ExpandProperty Splunk_HECName | Where-Object Name -EQ $SplunkHECName) {
                $SplunkObject = $Preferences.Preferences.Splunk | Select-Object -ExpandProperty Splunk_HECName | Where-Object Name -EQ $SplunkHECName

                ForEach ($Item in ($SplunkObject | Get-Member -MemberType Property | Where-Object Definition -Match string).Name) {
                    $SplunkObject.$Item = $SplunkObject.$Item -replace '"', '' -replace "'", ''
                }
            }
            else {
                $ExitCode = 1
                Throw "Splunk: $SplunkHECName not found or parameter missing."
            }
            if (-Not($SplunkObject.Splunk_token)) {
                $ExitCode = 1
                Throw "Splunk preferences missing Splunk_token."
            }
        }

        # Validate AFPath
        If ($AFPath) {
            If (-Not($AFPath | Test-Path)) {
                $ExitCode = 3
                Throw "-AFPath either does not exist or is not accessible."
            }
            ElseIf (($AFPath | Test-Path) -and (-Not($AFPath | Test-Path -PathType 'Container' -ErrorAction SilentlyContinue))) {
                $ExitCode = 1
                Throw "-AFPath must point to a directory."
            }
        }

        # Validate OutputPath
        If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)") {
            Switch ($OSPlatform) {
                "Windows" {
                    $DefaultOutputPath = [IO.Path]::GetFullPath("$($env:PUBLIC)\Documents\STIG_Compliance")
                    If ((-Not($OutputPath)) -or [IO.Path]::GetFullPath($(($OutputPath).Replace("/", "\")) -replace "\\$") -eq $DefaultOutputPath) {
                        $OutputPath = "$env:PUBLIC\Documents\STIG_Compliance"
                        If (-Not(Test-Path $OutputPath)) {
                            $null = New-Item -Path $(Split-Path -Path $OutputPath -Parent) -Name $(Split-Path -Path $OutputPath -Leaf) -ItemType Directory
                        }
                    }
                }
                "Linux" {
                    $DefaultOutputPath = [IO.Path]::GetFullPath("\opt\STIG_Compliance")
                    If ((-Not($OutputPath)) -or [IO.Path]::GetFullPath($(($OutputPath).Replace("\", "/")) -replace "/$") -eq $DefaultOutputPath) {
                        $OutputPath = "/opt/STIG_Compliance"
                        If (-Not(Test-Path $OutputPath)) {
                            sudo mkdir $OutputPath
                        }
                    }
                }
            }
            If (-Not($OutputPath | Test-Path)) {
                $ExitCode = 3
                Throw "-OutputPath either does not exist or is not accessible."
            }
            ElseIf (($OutputPath | Test-Path) -and (-Not($OutputPath | Test-Path -PathType 'Container' -ErrorAction SilentlyContinue))) {
                $ExitCode = 1
                Throw "-OutputPath must point to a directory."
            }

            $OutputPath = Convert-Path (Resolve-Path -Path $OutputPath -ErrorAction Stop).Path
        }

        # Set initial variables
        $Global:ESVersion = $EvaluateStigVersion
        $Global:LogComponent = "Evaluate-STIG $($ESVersion) [PID: $(([System.Diagnostics.Process]::GetCurrentProcess()).ID)]"

        # If -AFPath not specified, set default
        If (-Not($AFPath)) {
            $AFPath = (Join-Path -Path $PsScriptRoot -ChildPath "AnswerFiles")
        }

        If ($host.privatedata) {
            Try {
                # Set Progress Bar Colors
                $host.privatedata.ProgressForegroundColor = "White"

                Switch ($ScanType) {
                    "Unclassified" {
                        $host.privatedata.ProgressBackgroundColor = "DarkGreen"
                    }
                    "Classified" {
                        $host.privatedata.ProgressBackgroundColor = "DarkRed"
                    }
                }
            }
            Catch {
                # Do nothing
            }
        }

        # Remove any invalid characters from Marking and TargetComments
        If ($Marking) {
            $Marking = (Repair-XmlString -String $Marking).ToUpper()
        }
        If ($TargetComments) {
            $TargetComments = Repair-XmlString -String $TargetComments
        }
        #region Remote Scan
        If ($ComputerName) {
            #####################################################
            # Scan remote system
            #####################################################
            If ($IsLinux) {
                $ExitCode = 1
                Throw "Parameter -ComputerName is only supported on Windows systems."
            }

            # Set working dir for remote scans
            Switch ($OSPlatform) {
                "Windows" {
                    $RemoteScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $RemoteScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $RemoteWorkingDir = Join-Path -Path $RemoteScanDir -ChildPath "RemoteScanTemp"

            If (-Not(Test-Path $RemoteScanDir)) {
                $null = New-Item -Path $RemoteScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $RemoteWorkingDir)) {
                $null = New-Item -Path $RemoteWorkingDir -ItemType Directory -ErrorAction Stop
            }

            # Check/Create lock file
            If (Test-Path (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck)) {
                $ProcLockInfo = Get-Content (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction Stop
                If ($ProcLockInfo) {
                    Try {
                        If (Get-Process -Name $ProcLockInfo.split("`r`n")[0] -ErrorAction SilentlyContinue | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                            $ExitCode = 33
                            Throw "Evaluate-STIG is currently processing remote scans from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])"
                        }
                    }
                    Catch {
                        Write-Host $_.Exception.Message -ForegroundColor Red -BackgroundColor Black
                        Exit $ExitCode
                    }
                }
            }
            $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
            Set-Content -Path (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

            # Get local host data
            $LocalHost = New-Object System.Collections.Generic.List[System.Object]
            $NewObj = [PSCustomObject]@{
                HostName    = ($(Get-FullHostName).FullName).ToUpper()
                IPv4Address = (Get-NetIPAddress).IPv4Address
            }
            $LocalHost.Add($NewObj)

            # If source machine is to be scanned, confirm PS is elevated or that -AltCredential is selected
            # TODO: Look into swapping this if () for Test-IsLocalHost
            If (($ComputerName -contains "127.0.0.1") -or ($ComputerName -contains "::1") -or ($ComputerName -contains "localhost") -or ($ComputerName -match $LocalHost.HostName) -or ($LocalHost.IPv4Address | ForEach-Object {If ($_ -in $ComputerName) {
                            Return $true
                        }})) {
                $isAdmin = Test-IsAdministrator
                If (-not($isAdmin -or $AltCredential)) {
                    $ExitCode = 5
                    Throw "LOCALHOST to be included in scan.  You must run this from an elevated PowerShell session or use -AltCredential."
                }
            }

            # Build arguments hashtable
            $HashArguments = @{
                ComputerName      = $ComputerName
                ScanType          = $ScanType
                VulnTimeout       = $VulnTimeout
                AFPath            = $AFPath
                AnswerKey         = $AnswerKey
                ESVersion         = $ESVersion
                LogComponent      = $LogComponent
                OSPlatform        = $OSPlatform
                ES_Path           = $PsScriptRoot
                RemoteScanDir     = $RemoteScanDir
                RemoteWorkingDir  = $RemoteWorkingDir
                PowerShellVersion = $PowerShellVersion
            }
            If ($Marking) {
                $HashArguments.Add("Marking", [Char]34 + $($Marking -replace '"', "'") + [Char]34)
            }
            If ($TargetComments) {
                $HashArguments.Add("TargetComments", [Char]34 + $($TargetComments -replace '"', "'") + [Char]34)
            }
            If ($Output) {
                $HashArguments.Add("Output", $($Output -join ","))

                If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)") {
                    $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                }

                If (($Output -split ",").Trim() -match "(^STIGManager$)") {
                    if ($SMPassphrase) {
                        $HashArguments.Add("SMPassphrase", $SMPassphrase)
                    }
                    if ($SMCollection) {
                        $HashArguments.Add("SMCollection", $SMCollection)
                    }
                }

                if (($Output -split ",").Trim() -match "(^Splunk$)") {
                    if ($SplunkHECName) {
                        $HashArguments.Add("SplunkHECName", $SplunkHECName)
                    }
                }

                If (($Output -Split ",").Trim() -match "(^CSV$|^CombinedCSV$|^Splunk$)") {
                    $HashArguments.Add("OutputPayload", $OutputPayload)
                }
            }
            If ($OutputPath) {
                $HashArguments.Add("OutputPath", $OutputPath)
            }
            If ($ApplyTattoo) {
                $HashArguments.Add("ApplyTattoo", $true)
            }
            If ($AllowDeprecated) {
                $HashArguments.Add("AllowDeprecated", $true)
            }
            If ($AllowSeverityOverride) {
                $HashArguments.Add("AllowSeverityOverride", $true)
            }
            If ($AllowIntegrityViolations) {
                $HashArguments.Add("AllowIntegrityViolations", $true)
            }
            If ($SelectSTIG) {
                $HashArguments.Add("SelectSTIG", $SelectSTIG)
            }
            If ($SelectVuln) {
                $HashArguments.Add("SelectVuln", $SelectVuln)
            }
            If ($ExcludeSTIG) {
                $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
            }
            If ($ExcludeVuln) {
                $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
            }
            If ($ForceSTIG) {
                $HashArguments.Add("ForceSTIG", $ForceSTIG)
            }
            If ($AltCredential) {
                $HashArguments.Add("AltCredential", $true)
            }
            If ($ThrottleLimit) {
                $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
            }

            $ScanResult = Invoke-RemoteScan @HashArguments

            If (Test-Path $RemoteWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $RemoteWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        #endregion Remote Scan
        #region Cisco Scan
        ElseIf ($CiscoConfig) {
            #####################################################
            # Scan Cisco Show Tech Files
            #####################################################
            # Set working dir for Cisco scans
            Switch ($OSPlatform) {
                "Windows" {
                    $CiscoScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $CiscoScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $CiscoWorkingDir = Join-Path -Path $CiscoScanDir -ChildPath "CiscoScanTemp"

            If (-Not(Test-Path $CiscoScanDir)) {
                $null = New-Item -Path $CiscoScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $CiscoWorkingDir)) {
                $null = New-Item -Path $CiscoWorkingDir -ItemType Directory -ErrorAction Stop
            }

            If (Test-Path $CiscoConfig -ErrorAction Stop) {
                # Test OutputPath connectivity
                If ($OutputPath -and -Not(Test-Path $OutputPath)) {
                    $ExitCode = 5
                    Throw "$OutputPath is not accessible by $([Environment]::Username) on $MachineName."
                }

                # Check/Create lock file
                If (Test-Path (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck)) {
                    $ProcLockInfo = Get-Content (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction Stop
                    If ($ProcLockInfo) {
                        Try {
                            If (Get-Process -Name $ProcLockInfo.split("`r`n")[0] -ErrorAction SilentlyContinue | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                                $ExitCode = 33
                                Throw "Evaluate-STIG is currently processing Cisco scans from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])"
                            }
                        }
                        Catch {
                            Write-Host $_.Exception.Message -ForegroundColor Red -BackgroundColor Black
                            Exit $ExitCode
                        }
                    }
                }
                $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
                Set-Content -Path (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

                # Build arguments hashtable
                $HashArguments = @{
                    CiscoConfig       = $CiscoConfig
                    ScanType          = $ScanType
                    VulnTimeout       = $VulnTimeout
                    AFPath            = $AFPath
                    AnswerKey         = $AnswerKey
                    ESVersion         = $ESVersion
                    LogComponent      = $LogComponent
                    OSPlatform        = $OSPlatform
                    ES_Path           = $PsScriptRoot
                    PowerShellVersion = $PowerShellVersion
                    CiscoScanDir      = $CiscoScanDir
                    CiscoWorkingDir   = $CiscoWorkingDir
                }
                If ($Marking) {
                    $HashArguments.Add("Marking", $Marking)
                }
                If ($TargetComments) {
                    $HashArguments.Add("TargetComments", $TargetComments)
                }
                If ($Output) {
                    $HashArguments.Add("Output", $Output)

                    If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)") {
                        $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                    }

                    If ("STIGManager" -in $Output) {
                        if ($SMPassphrase) {
                            $HashArguments.Add("SMPassphrase", $SMPassphrase)
                        }
                        if ($SMCollection) {
                            $HashArguments.Add("SMCollection", $SMCollection)
                        }
                    }

                    if ("Splunk" -in $Output) {
                        if ($SplunkHECName) {
                            $HashArguments.Add("SplunkHECName", $SplunkHECName)
                        }
                    }

                    If (($Output -split ",").Trim() -match "(^CSV$|^CombinedCSV$|^Splunk$)") {
                        $HashArguments.Add("OutputPayload", $OutputPayload)
                    }
                }
                If ($OutputPath) {
                    $HashArguments.Add("OutputPath", $OutputPath)
                }
                If ($AllowDeprecated) {
                    $HashArguments.Add("AllowDeprecated", $true)
                }
                If ($AllowSeverityOverride) {
                    $HashArguments.Add("AllowSeverityOverride", $true)
                }
                If ($AllowIntegrityViolations) {
                    $HashArguments.Add("AllowIntegrityViolations", $true)
                }
                If ($SelectSTIG) {
                    $HashArguments.Add("SelectSTIG", $SelectSTIG)
                }
                If ($SelectVuln) {
                    $HashArguments.Add("SelectVuln", $SelectVuln)
                }
                If ($ExcludeSTIG) {
                    $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
                }
                If ($ExcludeVuln) {
                    $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                }
                If ($ForceSTIG) {
                    $HashArguments.Add("ForceSTIG", $ForceSTIG)
                }
                If ($ThrottleLimit) {
                    $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
                }
                If ($SelectDeviceType) {
                    $HashArguments.Add("SelectDeviceType", $(($SelectDeviceType -split ",").Trim() | Select-Object -Unique))
                }

                $ScanResult = Invoke-ConfigFileScan @HashArguments
            }
            Else {
                $ExitCode = 3
                Throw "Cannot find path '$CiscoConfig' because it does not exist."
            }
            If (Test-Path $CiscoWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $CiscoWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        #endregion Cisco Scan
        #region VMWare Scan
        ElseIf ($ESXiApplianceName -or $VCenterApplianceName) {
            # TODO: THIS IS PRE-STAGING. NOT IN USE AT THIS TIME.
            #####################################################
            # Scan VCenter Appliance or VM
            #####################################################
            # TODO: Confirm if PowerCLI works w/ 5.2 AND 7.X. If ONLY 5.2 is useable remove any references to Linux.
            # both 5.2 and 7.X seem to support PowerCLI. Need to test PowerCLI + Linux
            # https://www.vgemba.net/vmware/PowerShell-PowerCLI-Part-1/
            # PowerCLI seems to support Linux
            # https://developer.vmware.com/docs/17472/-compatibility-matrix
            # TODO: Test if a process lock is required.

            # Setup Initial variables
            $StartTime = Get-Date
            $Date      = Get-Date -Format yyyyMMdd
            $Global:ScanStartDate = (Get-Date -Format "MM/dd/yyyy")

            # Ensure required modules are available
            $RequiredModules = @('VMWare.PowerCLI', 'VMWare.vSphere.SsoAdmin')
            $AvailableModules = (Get-Module -ListAvailable -All).Name
            Foreach ($Requirement in $RequiredModules) {
                # TODO: Error out unable to process b/c module is missing
                $ExitCode = 1
                throw "'$Requirement' module is NOT available to PowerShell. VMWare checklists will NOT be generated."
            }
            Remove-Variable -Name 'AvailableModules'


            # Configure CEIP (per user)
            $CEIP = (Get-PowerCLIConfiguration -Scope User).ParticipateInCEIP
            if (($null -eq $CEIP) -or ($CEIP -eq $true)) {
                $null = Set-PowerCLIConfiguration -Scope User -ParticipateInCeip $false -Confirm:$false
            }

            # Normalize name variables
            $VCenterAppliances = $VCenterApplianceName | Split-Trim
            $ESXiAppliances    = $ESXiApplianceName | Split-Trim

            # Validate privileges and set working dir for vCenter Scans
            Switch ($OSPlatform) {
                'Windows' {
                    # Confirm elevated session
                    $isAdmin = Test-IsAdministrator
                    If (-not ($isAdmin) -and -not ($AltCredential) -and ($LinuxList.Count -eq 0)) {
                        $ExitCode = 5
                        throw "You must run this from an elevated PowerShell session or use -AltCredential."
                    }

                    $VCenterScanDir    = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                    $Global:WorkingDir = Join-Path -Path $env:windir -ChildPath 'Temp\Evaluate-STIG'
                    $Global:STIGLog    = Join-Path -Path $WorkingDir -ChildPath "Evaluate-STIG.log"
                    $VCenterWorkingDir = Join-Path -Path $VCenterScanDir -ChildPath "VCenterScanTemp"

                    $Splat_WriteLog = @{
                        Path       = $STIGLog
                        Component  = $LogComponent
                        OSPlatform = $OSPlatform
                    }

                    # =========== Determine User ===========
                    $UserToProcess = Get-UsersToEval -ProvideSingleUser
                    If ($UserToProcess) {
                        $policyUpdateLine = if ($UserToProcess.LastPolicyUpdate -eq 'Never') {
                            "    Policy Updated: $($UserToProcess.LastPolicyUpdate)"
                        } Else {
                            $days = (New-TimeSpan -Start $UserToProcess.LastPolicyUpdate -End (Get-Date)).Days
                            '    Policy Updated: {0} ({1} days ago)' -f $UserToProcess.LastPolicyUpdate, $days
                        }

                        $MessageArray = @(
                            'Will evaluate {0} for user-based settings' -f $UserToProcess.Username
                            '    SID: {0}' -f $UserToProcess.SID
                            $policyUpdateLine
                            '    Last Used: {0}' -f $UserToProcess.LastUseTime
                            '    Profile Path: {0}' -f $UserToProcess.LocalPath
                        ) | Where-Object { $_ }  # drop nulls just in case

                        Foreach ($m in $MessageArray) { Write-Log @Splat_WriteLog -Type Info -Message $m }
                    } Else {
                        $wrnMsg = 'WARNING: No scannable user profile found. Will evaluate .DEFAULT profile for user-based settings.'
                        Write-Log @Splat_WriteLog -Type 'Warn' -Message $wrnMsg

                        $UserToProcess = @{
                            Username = '.DEFAULT'
                            SID      = '.DEFAULT'
                        }
                    }
                }
                'Linux' {
                    # Confirm we have an elevated session
                    If ((id -u) -ne 0) {
                        $ExitCode = 5
                        throw "You must run this from an elevated PowerShell session."
                    }

                    $VCenterScanDir    = '/tmp/Evaluate-STIG'
                    $Global:WorkingDir = '/tmp/Evaluate-STIG'
                    $Global:STIGLog    = Join-Path -Path $WorkingDir -ChildPath "Evaluate-STIG.log"
                    $VCenterWorkingDir = Join-Path -Path $VCenterScanDir -ChildPath "VCenterScanTemp"

                    # Set Username and SID to "NA"
                    $UserToProcess = @{
                        Username = whoami
                        SID      = 'NA'
                    }
                }
            }

            # Create WorkingDir
            If (-Not(Test-Path $WorkingDir)) {
                $null = New-Item $WorkingDir -ItemType Directory
            }

            # Check/Create lock file
            $ProcLockInfo = Get-Content (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction SilentlyContinue
            If ($ProcLockInfo) {
                if (Get-Process -Name $ProcLockInfo.split("`r`n")[0] | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                    $ExitCode = 33
                    Throw "Evaluate-STIG is currently processing from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])"
                }
            }
            $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
            Set-Content -Path (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

            # Create VCenter-specific folders
            If (-Not(Test-Path $VCenterScanDir)) {
                $null = New-Item -Path $VCenterScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $VCenterWorkingDir)) {
                $null = New-Item -Path $VCenterWorkingDir -ItemType Directory -ErrorAction Stop
            }

            # Import required modules
            Write-Log @Splat_WriteLog -Type 'Info' -Message 'Importing scan module: VMWare_Functions'
            $modulePath = Join-Path -Path $PsScriptRoot -ChildPath "Modules" |
                Join-Path -ChildPath "VMWare_Functions"
            $importParams = @{ LiteralPath = $modulePath; ErrorAction = 'Stop' }
            # Add SkipEditionCheck only if supported
            If ((Get-Command Import-Module).Parameters.ContainsKey('SkipEditionCheck')) {
                $importParams.SkipEditionCheck = $true
            }
            Import-Module @importParams

            # Test OutputPath connectivity
            If ($OutputPath -and -not (Test-Path -Path $OutputPath)) {
                $ExitCode = 5
                throw "'$OutputPath' is NOT accessible by '$([Environment]::Username)' on '$MachineName'."
            }

            $FolderName = "VMWare"
            If ($OutputPath) {
                If ($SelectVuln) {
                    $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath "_Partial_$FolderName"
                }
                Else {
                    $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath $FolderName
                }
            }

            [int]$Global:TotalMainSteps = 1
            [int]$Global:CurrentMainStep = 1
            [int]$Global:ProgressId = 1

            if ($Marking) {
                $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Marking: $Marking | Answer Key: $AnswerKey)"
            }
            else {
                $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Answer Key: $AnswerKey)"
            }

            # ++++++++++++++++++++++ Begin processing ++++++++++++++++++++++
            # Write Progress bar to console
            $Splat_Progress = @{ Id = $ProgressId; Activity = $ProgressActivity }
            Write-Progress @Splat_Progress -Status 'Initilizing and generating list of required STIGs.'
            # Remove old log if it exists
            If (Test-Path -Path $STIGLog) { Remove-Item -Path $STIGLog -Force}
            # Handle Marking
            If ($Marking) {
                Write-Log @Splat_WriteLog -Type 'Info' -Message $(Out-CenterString -Text $Marking)
            }
            # Initialize logging
            Write-Log -Path $STIGLog -Message "Begin Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            if ($SMPassphrase) {
                Write-Log -Path $STIGLog -Message "Executing: $(($MyInvocation.Line).Replace((($MyInvocation.Line).split("-") | Where-Object {$_ -match "Passphrase"}),'SMPassphrase ************** '))" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            else {
                Write-Log -Path $STIGLog -Message "Executing: $($MyInvocation.Line)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            $InUsePrefs | ForEach-Object {
                Write-Log -Path $STIGLog -Message "Utilizing Preference: $($_) $($Preferences.Preferences.EvaluateSTIG.$_)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            If (($Output -split ",").Trim() -match "(^CSV$|^CombinedCSV$|^Splunk$)" -or $JSON) {
                Write-Log -Path $STIGLog -Message "Utilizing Output Payload: $($OutputPayload -join ",")" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Verify Evaluate-STIG file integrity
            Write-Log @Splat_WriteLog -Type 'Info' -Message 'Verifying Evaluate-STIG file integrity'
            If (Test-Path (Join-Path -Path $PSScriptRoot -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")) {
                    $FileListPath     = Join-Path -Path $PSScriptRoot -ChildPath 'xml' |
                        Join-Path -ChildPath 'FileList.xml'
                    [xml]$FileListXML = Get-Content -Path $FileListPath
                    $isFileListValid = Test-XmlSignature -checkxml $FileListXML -Force
                    switch ($isFileListValid) {
                        $true {
                            $Verified = $true
                            $XccdfFailedHash = @()

                            Foreach ($File in $FileListXML.FileList.File) {
                                $FilePath = Join-Path -Path $PSScriptRoot -ChildPath $File.Path |
                                    Join-Path -ChildPath $File.Name
                                If (Test-Path -Path $Filepath) {
                                    If ((Get-FileHash -Path $FilePath -Algorithm SHA256).Hash -ne $File.SHA256Hash) {
                                        $Verified = $false
                                        If ($File.Name -like "*xccdf.xml") { $XccdfFailedHash += $File.Name }
                                        Write-Log @Splat_WriteLog -Type 'Warning' -Message "WARNING: '$($Path)' failed integrity check."
                                    }
                                } Else {
                                    If ($File.ScanReq -eq 'Required') {
                                        $Verified = $false
                                        Write-Log @Splat_WriteLog -Type 'Error' -WriteOutToStream -Message "ERROR: '$($File.Name)' is a required file but not found.  Scan results may be incomplete."
                                    }
                                }

                                If ($Verified -eq $true) {
                                    Write-Log @Splat_WriteLog -Type 'Info' -WriteOutToStream -Message "Evaluate-STIG file integrity check passed."
                                } else {
                                    Write-Log @Splat_WriteLog -Type 'Info' -WriteOutToStream -Message "WARNING: One or more Evaluate-STIG files failed integrity check."
                                }
                            }
                        }
                        $false {
                            Write-Log @Splat_WriteLog -Type 'Error' -Message "ERROR: 'FileList.xml' failed authenticity check. Unable to verify content integrity." -WriteOutToStream
                        }
                        DEFAULT {
                            Write-Log @Splat_WriteLog -Type 'Error' -Message "ERROR: Test-XmlSignature on 'FileList.xml' failed with the following message:" -WriteOutToStream
                            Write-Log @Splat_WriteLog -Type 'Error' -Message $isFileListValid -WriteOutToStream
                        }
                    }
            } Else {
                ExitCode = 2
                Write-Log @Splat_WriteLog -Type 'Error' -Message "'FileList.xml' NOT found."
                throw "'FileList.xml' NOT found."
            }

            # Schema File Validation
            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $AnswerFile_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_AnswerFile.xsd"
            $Checklist_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "U_Checklist_Schema_V2.xsd"
            $Checklist_json = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "CKLB.schema.json"
            If (-Not(Test-Path $STIGList_xsd)) {
                $ExitCode = 2
                Throw "'$STIGList_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $AnswerFile_xsd)) {
                $ExitCode = 2
                Throw "'$AnswerFile_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $Checklist_xsd)) {
                $ExitCode = 2
                Throw "'$Checklist_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $Checklist_json)) {
                $ExitCode = 2
                Throw "'$Checklist_json' - file not found."
            }

            # STIGList.xml validation
            $STIGListXMLFilePath = Join-Path -Path $PSScriptRoot -ChildPath 'xml' |
                Join-Path -ChildPath 'STIGList.xml'
            If (-not (Test-Path -Path $STIGListXMLFilePath)) {
                $ExitCode = 2
                throw "'$STIGListXMLFilePath' - file not found"
            } Else {
                $Result = Test-XmlValidation -XmlFile $STIGListXMLFilePath -SchemaFile $STIGList_xsd
                If ($Result -ne $true) {
                    Foreach ($Item in $Result.Message) {

                    }
                    $ExitCode = 1
                    throw "'$STIGListXMLFilePath' failed XML validation"
                }
            }

            # Pre-checks passed.  Begin processing.
            # =====================================
            # Write configuration data to log
            $MessageArray = @(
                "Evaluate-STIG Version: $ESVersion"
                "Launching User: $([Environment]::Username)"
                "Hostname: $MachineName"
                "Domain Role: $DomainRole"
                "OS Platform: $OSPlatform"
                "PS Version: $PowerShellVersion"
                "Scan Type: $ScanType"
                "Answer Key: $AnswerKey"
                "Answer File Path: $AFPath"
                "Results Path: $ResultsPath"
            )
            Foreach ($line in $MessageArray) {
                Write-Log @Splat_WriteLog -Type 'Info' -Message $line
            }
            Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash

            # --- Begin Answer File Validation
            Write-Log @Splat_WriteLog -Type 'Info' -Message 'Validating answer files'
            $AnswerFileList = [System.Collections.Generic.List[System.Object]]::new()
            $XmlFiles = Get-ChildItem -Path $AFPath | Where-Object { $_.Extension -eq '.xml' }

            # Verify answer files for property format
            Foreach ($Item in $XmlFiles) {
                $Validation = Test-XmlValidation -XmlFile $Item.FullName -SchemaFile $AnswerFile_xsd
                If ($Validation -eq $true) {
                    Write-Log @Splat_WriteLog -Type 'Info' -Message "$($Item.Name) : Passed"
                    [xml]$Content = Get-Content -Path $Item.FullName
                    If ($Content.STIGComments.Name) {
                        $NewObj = [PSCustomObject]@{
                            STIG          = $Content.STIGComments.Name
                            Name          = $Item.Name
                            FullName      = $Item.FullName
                            LastWriteTime = $Item.LastWriteTime
                        }
                        $AnswerFileList.Add($NewObj)
                    }
                } Else {
                    Write-Log @Splat_WriteLog -Type 'Error' -WriteOutToStream -Message "ERROR: $($Item.Name) : Answer file failed schema validation and will be ignored.  Please correct or remove."
                    Write-Log @Splat_WriteLog -Type 'Error' -WriteOutToStream -Message "$($Validation.Message)"
                }
            }
            $AnswerFileList = $AnswerFileList | Sort-Object -Property LastWriteTime -Descending
            Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash

            [xml]$STIGList = Get-Content -Path $STIGListXMLFilePath
            $STIGsToProcess = [System.Collections.Generic.List[System.Object]]::new()

            ##### BEGIN LOOP VMWARE 7/8 STIGS #####
            $STIGs = @()
            # TODO: Where does this variable come from?
            Foreach ($VMWareSTIGName in $SupportedVMWarevSphereSTIGs) {
                If ($SelectSTIG) {
                    $STIGs += ($STIGList.List.STIG | Where-Object {$_.DisaCommonName -eq $VMWareSTIGName -and $_.ShortName -in $SelectSTIG})
                } ElseIf ($ExcludeSTIG) {
                    $STIGs += ($STIGList.List.STIG | Where-Object {$_.DisaCommonName -eq $VMWareSTIGName -and $_.ShortName -notin $ExcludeSTIG})
                } Else {
                    $STIGs += ($STIGList.List.STIG | Where-Object {$_.DisaCommonName -eq $VMWareSTIGName})
                }
            }

            Foreach ($STIG in $STIGs) {
                If ($AnswerFileList | Where-Object {($_.STIG -eq $STIG.ShortName -or $_.STIG -eq $STIG.Name)}) {
                    $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $STIG.ShortName -or $_.STIG -eq $STIG.Name)})[0]
                } Else { $AFtoUse = '' }

                # Determine deprecation
                $Deprecated = $false
                If ($STIG.DisaStatus -eq 'Deprecated') { $Deprecated = $true }

                $NewObj = [PSCustomObject]@{
                    Name           = $STIG.Name
                    Shortname      = $STIG.ShortName
                    StigContent    = $STIG.StigContent
                    AnswerFile     = $AFtoUse
                    PsModule       = $STIG.PsModule
                    PsModuleVer    = $STIG.PsModuleVer
                    UserSettings   = $STIG.UserSettings
                    CanCombine     = $STIG.CanCombine
                    Classification = $STIG.Classification
                    Deprecated     = $Deprecated
                    Forced         = $false
                }
                $STIGsToProcess.Add($NewObj)
            }

            # This check is used in multiple places so just do it once.
            $isFormattedOutputRegexMatch = ($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$|^CSV$|^CombinedCSV$)"

            # Manage previous results and move results to ResultsPath
            If ($isFormattedOutputRegexMatch) {
                $Splat_IntPrevProc = @{
                    ResultsPath    = $ResultsPath
                    PreviousToKeep = $PreviousToKeep
                    LogPath        = $STIGLog
                    LogComponent   = $LogComponent
                    OSPlatform     = $OSPlatform
                }
                If ($SelectSTIG) {
                    $Splat_IntPrevProc.Add('SelectedShortName', $($STIGsToProcess.ShortName))
                    If (($Output -split ",").Trim() -match "(^CombinedCKL$)") {
                        $Splat_IntPrevProc.Add("SelectedCombinedCKL", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^CombinedCKLB$)") {
                        $Splat_IntPrevProc.Add("SelectedCombinedCKLB", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^CombinedCSV$)") {
                        $Splat_IntPrevProc.Add("SelectedCombinedCSV", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^Summary$)") {
                        $Splat_IntPrevProc.Add("SelectedSummary", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^OQE$)") {
                        $Splat_IntPrevProc.Add("SelectedOQE", $true)
                    }
                }
                Initialize-PreviousProcessing @Splat_IntPrevProc
            }
            Write-Log @Splat_WriteLog -Type 'Info' -WriteOutToStream -FGColor Magenta -Message "STIGs to process - $(($STIGsToProcess | Measure-Object).count)"
            ##### END LOOP VMWARE 7/8 STIGS #####

            # Test connectivity to OutputPath and create folder for computer
            Try {
                If ($isFormattedOutputRegexMatch -and (-Not(Test-Path -Path $ResultsPath))) {
                    $null = New-Item -Path $ResultsPath -ItemType Directory -ErrorAction Stop
                    Start-Sleep -Seconds 5
                }
            }
            Catch {
                Write-Log @Splat_WriteLog -Type 'Error' -Message "ERROR: Failed to create output path '$($ResultsPath)'"
                $ExitCode = 1
                throw $_
            }

            # Cleanup orphaned objects in temp
            $Tempfiles = Get-Item -Path $WorkingDir\* -Exclude Evaluate-STIG.log, Evaluate-STIG.lck -Force
            If ($Tempfiles) {
                Write-Log @Splat_WriteLog -Type 'Info' -Message "Removing orphaned objects: $($Item.FullName)"
                $null = Remove-Item -Path $Item.FullName -Recurse -Force -ErrorAction Stop
            }

            # Increase $TotalMainSteps based on options/STIGs
            If (($Output -split ",").Trim() -match "(^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^STIGManager$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^Splunk$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^Summary$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^OQE$)") {
                $TotalMainSteps++
            }

            If ($STIGsToProcess | Where-Object UserSettings -EQ $true) {
                $TotalMainSteps++
            }

            # =========== Run the scans ===========
            If ($isFormattedOutputRegexMatch) {
                # tmpResultsPath is needed for all filetype Outputs
                $tmpResultsPath = Join-Path -Path $WorkingDir -ChildPath 'Results'
                If (-not (Test-Path -Path $tmpResultsPath)) {
                    $null = New-Item -Path $tmpResultsPath -ItemType Directory
                }
            }

            $ScanObjects           = [System.Collections.Generic.List[System.Object]]::new()
            $ScanJobs              = [System.Collections.Generic.List[System.Object]]::new()
            $global:SSHConnections = [System.Collections.ArrayList]::new()

            # =========== Begin Loop through VCenter Appliances  ===========

            Foreach ($Appliance in @($VCenterAppliances, $ESXiAppliances) | Where-Object { $null -ne $_}) {
                Foreach ($Item in $STIGsToProcess) {
                    $VCenterSTIG = $false
                    $VMStig      = $false

                    Try {
                        if ($Item.Name -match "vCenter|VAMI|Photon") {
                            $VCenterSTIG = $true
                        }
                        elseif ($Item.Name -match "Virtual_Machine") {
                            $VMSTIG = $true
                        }

                        # Create subjobs object for STIGs that may apply multiple times (IIS, SQL, VM, etc)
                        $SubJobs = [System.Collections.Generic.List[System.Object]]::new()

                        # Temporarily import scan module for access to custom functions
                        $modulePath = Join-Path -Path $PsScriptRoot -ChildPath "Modules" |
                            Join-Path -ChildPath $($Item.PsModule)
                        $importParams = @{ LiteralPath = $modulePath; ErrorAction = 'Stop' }
                        # Add SkipEditionCheck only if supported
                        If ((Get-Command Import-Module).Parameters.ContainsKey('SkipEditionCheck')) {
                            $importParams.SkipEditionCheck = $true
                        }
                        Import-Module @importParams

                        If ($VCenterAppliances -contains $Appliance) {
                            If (-not (Test-VIServerConnection -VIServer $Appliance)) {
                                Write-Log @Splat_WriteLog -Type 'Info' -Message "Connecting to VSphere appliance: $($appliance)"

                                $splat_vSphereInstance = @{
                                    HostType           = 'VCenter'
                                    VIServer           = $Appliance
                                    PuttyPath          = $PuttyPath
                                    AcceptSSHHostKeys  = $AcceptSSHHostKeys
                                    TryCredentialReuse = $TryCredentialReuse
                                }
                                $vSphereInstances = @(Get-vSphereInstances @splat_vSphereInstance)
                                $vSphereInstances = $vSphereInstances[0] # return single vCenter record per ESXi in cluster. Only need the first one.
                            }
                            If ($($vSphereInstances.VIApplianceType) -ne 'VCenter') {
                                Write-Log @Splat_WriteLog -Type 'Error' -Message "Appliance: $appliance is not VCenter Appliance Type, STIG: $($Item.Name) - Skipping" -WriteOutToStream -FGColor Red
                                Continue
                            }
                        } ElseIf ($ESXiAppliances -contains $Appliance) {
                            If (-not (Test-VIServerConnection -VIServer $Appliance)) {
                                Write-Log @Splat_WriteLog -Type 'Info' -Message "Connecting to ESXi appliance: $($appliance)"

                                $splat_vSphereInstance = @{
                                    HostType           = 'ESXi'
                                    VIServer           = $Appliance
                                    PuttyPath          = $PuttyPath
                                    AcceptSSHHostKeys  = $AcceptSSHHostKeys
                                    TryCredentialReuse = $TryCredentialReuse
                                }
                                $vSphereInstances = @(Get-vSphereInstances @splat_vSphereInstance)
                            }
                           If ($($vSphereInstances.VIApplianceType) -ne 'ESXi') {
                                Write-Log @Splat_WriteLog -Type 'Error' -Message "Appliance: $appliance is not VCenter Appliance Type, STIG: $($Item.Name) - Skipping" -WriteOutToStream -FGColor Red
                                Continue
                            }
                        }

                        # Set path to STIG XCCDF .xml and obtain needed data from it
                        $STIGXmlPath = Join-Path -Path $PSScriptRoot -ChildPath 'StigContent' |
                            Join-Path -ChildPath $Item.StigContent
                        [xml]$XCCDFXml = Get-Content -LiteralPath $STIGXmlPath -Raw

                        $STIGId    = $XCCDFXml.Benchmark.id.trim()
                        $STIGTitle = $XCCDFXml.Benchmark.title.trim()
                        $STIGVer   = $XCCDFXml.Benchmark.version.trim()
                        $STIGTargetKey = $XCCDFXml.Benchmark.Group[0].Rule.reference.identifier

                        # release-info line: e.g. "Version 2, Release 8 Benchmark Date: 15 Jul 2024"
                        $ReleaseInfo = ($XCCDFXml.Benchmark.'plain-text' | Where-Object { $_.id -eq 'release-info' }).InnerText
                        $STIGRel   = if ($releaseInfo -match 'Release\s*(\d+)') { $Matches[1] } else { $null }
                        $STIGDate  = if ($releaseInfo -match 'Date:\s*(.+)$') { $Matches[1] } else { $null }
                        $STIGVersion    = 'V{0}R{1}' -f $STIGVer, $STIGRel

                        # Set STIG Classification
                        $STIGStyleSheet = $XCCDFXml.SelectSingleNode("processing-instruction('xml-stylesheet')")
                        $Classification = Switch -Regex ($STIGStyleSheet) {
                            'STIG_unclass\.xsl' { 'UNCLASSIFIED' }
                            'STIG_cui\.xsl'     { 'CUI' }
                            default             {
                                if ($STIGStyleSheet) { "Unknown ($STIGStyleSheet)" } else { 'Unknown' }
                            }
                        }

                        # Build STIGInfo & STIGData Objects
                        $STIGInfo = [ordered]@{
                            STIGID         = $STIGID
                            Title          = $STIGTitle
                            Version        = $STIGVer
                            Release        = $STIGRel
                            ReleaseDate    = $STIGDate
                            Classification = $Classification
                        }

                        $STIGData = @{
                            StigXmlPath = $StigXmlPath
                            StigVersion = $STIGVersion
                            Name        = $Item.Name
                            ShortName   = $Item.ShortName
                            PsModule    = $Item.PsModule
                            CanCombine  = $Item.CanCombine
                        }

                        # Build Arguments to run the specific scan.
                        $ScanArgs = @{
                            StigXmlPath           = $StigXmlPath
                            VulnTimeout           = $($VulnTimeout)
                            SelectVuln            = $SelectVuln
                            ExcludeVuln           = $ExcludeVuln
                            Deprecated            = $Item.Deprecated
                            AllowSeverityOverride = $AllowSeverityOverride
                            Forced                = $Item.Forced
                            ModulesPath           = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules")
                            PsModule              = $Item.PsModule
                            LogPath               = $STIGLog
                            OSPlatform            = $OSPlatform
                            ProgressId            = $ProgressId
                            ModuleArgs            = @{} # Initialze ModuleArgs object
                        }

                        $moduleArgs = @{
                            # Common arguments for scan module.
                            ScanType     = $ScanType
                            AnswerFile   = if ($Item.AnswerFile.FullName) { $Item.AnswerFile.FullName } else { "" }
                            AnswerKey    = $AnswerKey
                            Username     = $UserToProcess.Username
                            UserSID      = $UserToProcess.SID
                            ESVersion    = $ESVersion
                            LogPath      = $STIGLog
                            OSPlatform   = $OSPlatform
                            LogComponent = $LogComponent
                            # additional module arguments
                            vSphereInstance        = $null
                            Instance               = ""
                            DefaultVIServer        = $null
                            DefaultVIServers       = $null
                            DefaultSsoAdminServers = $null
                            DefaultCisServers      = $null
                            Shell                  = $null
                            VM                     = $null
                        }
                        Foreach ($kv in $moduleArgs.GetEnumerator()) {
                            $ScanArgs.ModuleArgs[$kv.Key] = $kv.Value
                        }

                        $ListOfProcessVMs = @()
                        Foreach ($instance in $vSphereInstances) {
                            $ScanArgs.ModuleArgs.vSphereInstance        = $instance
                            $ScanArgs.ModuleArgs.DefaultVIServer        = ($instance.DefaultVIServer)
                            $ScanArgs.ModuleArgs.DefaultVIServers       = ($instance.DefaultVIServers)
                            $ScanArgs.ModuleArgs.DefaultSsoAdminServers = ($instance.DefaultSsoAdminServers)
                            $ScanArgs.ModuleArgs.DefaultCisServers      = ($instance.DefaultCisServers)

                            $vSphereVersionCheck = switch ($item.Name) {
                                "7-0" { "^7." }
                                "8-0" { "^8." }
                                default { 'undefined' }
                            }

                            $VersionNumber = $instance.DefaultVIServer |
                                Select-Object Version -ExpandProperty Version

                            if ($VersionNumber -notmatch $vSphereVersionCheck) {
                                Write-Log @Splat_WriteLog -Type 'Warning' -Message "Unable to process $($Item.ShortName), STIG version differs from appliance version [$VersionNumber] - skipping"
                                continue
                            }

                            if ($VMStig) {
                                Foreach ($VM in $Instance.VM) {
                                    $VName = $VM.VMInfo.Name
                                    if ($ListOfProcessVMs -contains $VName) { Continue }

                                    # TODO: Circle back and ensure -VMName is handled appropriately
                                    if (-not $VMName -or ($VMName -match $VName)) {
                                        $ScanArgs.ModuleArgs.Instance = "$($Instance.DefaultVIServer.Name)-$($VName)"
                                        $ScanArgs.ModuleArgs.VM       = $($vm.VMInfo)
                                        $ScanArgs.ModuleArgs.Shell    = Get-Shell -SSHServer $($Instance.VMHost.Name)

                                        # Set output filename
                                        $Splat_BaseFileName = @{
                                            Hostname       = 'VMWare'
                                            STIGShortName  = $STIGData.ShortName
                                            SiteOrInstance = $ScanArgs.ModuleArgs.Instance
                                            STIGVersion    = $STIGData.StigVersion
                                        }
                                        $BaseFileName = Format-BaseFileName @Splat_BaseFileName

                                        # Build TargetData Object
                                        $TargetData = Get-AssetData -OSPlatform 'VMWare' -VMWareInfo $($instance.VMWareInfo) # -Marking $Marking
                                        # Append/overwrite desired fields (idempotent). Set if needed.
                                        $TargetData['Targetkey']     = $STIGTargetKey
                                        $TargetData['WebOrDatabase'] = $false
                                        $TargetData['Site']          = ''
                                        $TargetData['Instance']      = ''

                                        # Build & add subjob
                                        $NewObj = [PSCustomObject]@{
                                            BaseFileName = $BaseFileName
                                            STIGInfo     = $STIGInfo
                                            TargetData   = (Get-DeepCopy $TargetData)
                                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                                        }
                                    }
                                }
                            } Else {
                                $AddSubJob = $false
                                if ($VCenterSTIG) {
                                    $ScanArgs.ModuleArgs.Instance = $($instance.DefaultVIServer.Name)
                                    $ScanArgs.ModuleArgs.Shell    = Get-Shell -SSHServer $($instance.DefaultVIServer.Name)

                                    if ($VCenterAppliances -contains $ScanArgs.ModuleArgs.Instance) {
                                        $AddSubJob = $true
                                    }
                                } Else {
                                    $AddSubJob = $true
                                    $ScanArgs.ModuleArgs.Instance = $($instance.VMHost.Name)
                                    $ScanArgs.ModuleArgs.Shell = Get-Shell -SSHServer $($instance.VMHost.Name)
                                }

                                If ($AddSubJob) {
                                    # Set output filename
                                    $Splat_BaseFileName = @{
                                        Hostname       = 'VMWare'
                                        STIGShortName  = $STIGData.ShortName
                                        SiteOrInstance = $ScanArgs.ModuleArgs.Instance
                                        STIGVersion    = $STIGData.StigVersion
                                    }
                                    $BaseFileName = Format-BaseFileName @Splat_BaseFileName

                                    # Build TargetData Object
                                    $TargetData = Get-AssetData -OSPlatform 'VMWare' -VMWareInfo $($instance.VMWareInfo) # -Marking $Marking
                                    # Append/overwrite desired fields (idempotent). Set if needed.
                                    $TargetData['Targetkey']     = $STIGTargetKey
                                    $TargetData['WebOrDatabase'] = $false
                                    $TargetData['Site']          = ''
                                    $TargetData['Instance']      = ''


                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                } Else {
                                    $errMsg = "Unable to process $($Item.ShortName), $($ScanArgs.ModuleArgs.Instance) does not apply - skipping"
                                    Write-Log @Splat_WriteLog -Type 'Error' -Message $errMsg -WriteOutToStream -FGColor Red
                                }
                            }
                        }

                        # Add scan job
                        $NewObj = [PSCustomObject]@{
                            STIGData = $STIGData
                            SubJobs  = $SubJobs
                        }
                        $ScanJobs.Add($NewObj)

                        $TotalMainSteps++
                        # Remove module after adding job to queue.  Will be imported for scan when needed.
                        #Remove-Module $Item.PsModule -Force
                    }
                    Catch {
                        $errMsgArray = @(
                            "Unable to process $($Item.ShortName) - skipping"
                            "    $($_.Exception.Message)"
                            "    $($_.InvocationInfo.ScriptName)"
                            "    Line: $($_.InvocationInfo.ScriptLineNumber)"
                            "    $(($_.InvocationInfo.Line).Trim())"
                        )
                        Foreach ($errMsg in $errMsgArray) {
                            Write-Log @Splat_WriteLog -WriteOutToStream -FGColor Red -Type 'Error' -Message $errMsg
                        }
                    }
                }
            }
            # =========== End Loop through VCenter Appliances  ===========

            # Execute the scan
            $FailedCheck = $false
            Foreach ($Job in $ScanJobs) {
                Try {
                    $Splat_Progress = @{
                        Id              = $ProgressId
                        Activity        = $ProgressActivity
                        Status          = "Evaluating STIG: $($Job.STIGData.Name)"
                        PercentComplete = ($CurrentMainStep / $TotalMainSteps * 100)
                    }
                    Write-Progress @Splat_Progress
                    Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash
                    $CurrentMainStep++
                    Write-Log @Splat_WriteLog -Type 'Info' -Message 'Invoking Scan'
                    $ModError = ''

                    Try {
                        Write-Log @Splat_WriteLog -Type 'Info' -Message "Importing scan module: $($Job.STIGData.PsModule)"

                        # Temporarily import scan module for access to custom functions
                        $modulePath = Join-Path -Path $PsScriptRoot -ChildPath "Modules" |
                            Join-Path -ChildPath $($Job.STIGData.PsModule)
                        $importParams = @{ LiteralPath = $modulePath; ErrorAction = 'Stop' }
                        # Add SkipEditionCheck only if supported
                        $isSkipEditionChk = (Get-Command Import-Module).Parameters.ContainsKey('SkipEditionCheck')
                        If ($isSkipEditionChk) { $importParams.SkipEditionCheck = $true }
                        Import-Module @importParams

                        $PsModule = (Get-Module $Job.STIGData.PsModule)
                        Write-Log @Splat_WriteLog -Type 'Info' -Message "Module Version: $($PsModule.Version)"
                    }
                    Catch {
                        $ModError = $_.Exception.Message
                    }

                    If ($ModError) {
                        # If module failed to import, display reason and continue to next STIG
                        Write-Log @Splat_WriteLog -Type 'Error' -WriteOutToStream -Message "ERROR: $($ModError)"
                        continue
                    }

                    # Build ESData Object
                    $ESData = [Ordered]@{
                        ESVersion     = $ESVersion
                        StartTime     = (Get-Date -Format 'o')
                        ModuleName    = $PsModule.Name
                        ModuleVersion = $PsModule.Version
                        STIGName      = $Job.STIGData.Name
                        STIGShortName = $Job.STIGData.ShortName
                        CanCombine    = $Job.STIGData.CanCombine
                        STIGXMLName   = $($Job.STIGData.StigXmlPath | Split-Path -Leaf)
                        BaseFileName  = ""
                        FileName      = ""
                    }

                    # Set filename and additional requirements
                    Foreach ($SubJob in $Job.SubJobs) {
                        # Update BaseFileName if -SelectVuln is used
                        If ($SelectVuln) { $SubJob.BaseFileName = 'Partial_{0}' -f $SubJob.BaseFileName }
                        $ESData.BaseFileName = $($SubJob.BaseFileName)

                        # Write Site/Instance info to log
                        If ($SubJob.TargetData.Site) {
                            $SiteInstanceMsg = 'Site: {0}' -f $SubJob.TargetData.Site
                        }
                        If ($SubJob.TargetData.Instance) {
                            $SiteInstanceMsg = 'Instance: {0}' -f $SubJob.TargetData.Instance
                        }
                        Write-Log @Splat_WriteLog -Type 'Info' -Message $SiteInstanceMsg

                        # Execute Scan
                        $ScanArgs    = $SubJob.ScanArgs
                        $VulnResults = Invoke-VSphereScan @ScanArgs

                        # Look for any failed checks
                        If ($VulnResults | Where-Object { $_.CheckError -eq $true }) { $FailedCheck = $true }

                        # Build ScanObject
                        $ScanObject = [System.Collections.Generic.List[System.Object]]::new()
                        $NewObj = [PSCustomObject]@{
                            ESData      = $ESData
                            STIGInfo    = $SubJob.STIGInfo
                            TargetData  = $SubJob.TargetData
                            VulnResults = $VulnResults
                        }
                        $ScanObject.Add($NewObj)

                        # Send ScanObject to Outputs (CKL, CKLB, CSV)
                        $OutputFileRegex = "(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^CSV$|^CombinedCSV$)"
                        If ($Output -split ','.Trim() -match $OutputFileRegex) {
                            $Splat_Progress = @{
                                Id              = ($ProgressId + 1)
                                ParentId        = $ProgressId
                                Activity        = "Generating checklists..."
                            }
                            Write-Progress @Splat_Progress

                            $tmpChecklistPath = Join-Path -Path $tmpResultsPath -ChildPath 'Checklist'
                            If (-not (Test-Path -Path $tmpChecklistPath)) {
                                $null = New-Item -Path $tmpChecklistPath -ItemType Directory
                            }

                            $GenerateSingleCKL  = $false
                            $GenerateSingleCKLB = $false
                            $GenerateSingleCSV  = $false

                            $isCanCombine = $ScanObject.ESData.CanCombine
                            Switch ($Output) {
                                "CKL"          { $GenerateSingleCKL = $true }
                                "CombinedCKL"  { if ($isCanCombine -ne $true) { $GenerateSingleCKL = $true } }
                                "CKLB"         { $GenerateSingleCKLB = $true }
                                "CombinedCKLB" { if ($isCanCombine -ne $true) { $GenerateSingleCKL = $true } }
                                "CSV"          { $GenerateSingleCSV = $true }
                                "CombinedCSV"  { if ($isCanCombine -ne $true) { $GenerateSingleCKL = $true } }
                            }

                            If ($GenerateSingleCKL) {
                                Write-Log @Splat_WriteLog -Type 'Info' -Message 'Creating CKL File'

                                $SaveFileName = '{0}_{1}.ckl' -f $($ESData.BaseFileName), $(Get-Date -Format yyyyMMdd-HHmmss)
                                $SaveFile     = Join-Path -Path $tmpChecklistPath -ChildPath $SaveFileName
                                $Splat_FormatCKL = @{
                                    SchemaPath   = $Checklist_xsd
                                    ScanObject   = $ScanObject
                                    OutputPath   = $SaveFile
                                    Marking      = $Marking
                                    WorkingDir   = $WorkingDir
                                    ESPath       = $PSScriptRoot
                                    OSPlatform   = $OSPlatform
                                    LogComponent = $LogComponent
                                }
                                $ChecklistValid = Format-CKL @Splat_FormatCKL

                                # Action for validation result
                                If ($ChecklistValid) {
                                    $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                }
                            }

                            If ($GenerateSingleCKLB) {
                                Write-Log @Splat_WriteLog -Type 'Info' -Message 'Creating CKLB File'

                                $SaveFileName = '{0}_{1}.cklb' -f $($ESData.BaseFileName), $(Get-Date -Format yyyyMMdd-HHmmss)
                                $SaveFile     = Join-Path -Path $tmpChecklistPath -ChildPath $SaveFileName
                                $Splat_FormatCKL = @{
                                    SchemaPath   = $Checklist_json
                                    ScanObject   = $ScanObject
                                    OutputPath   = $SaveFile
                                    #Marking      = $Marking
                                    WorkingDir   = $WorkingDir
                                    ESPath       = $PSScriptRoot
                                    OSPlatform   = $OSPlatform
                                    LogComponent = $LogComponent
                                }
                                $ChecklistValid = Format-CKL @Splat_FormatCKL

                                # Action for validation result
                                If ($ChecklistValid) {
                                    $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                }
                            }

                            If ($GenerateSingleCSV) {
                                Write-Log @Splat_WriteLog -Type 'Info' -Message 'Creating CSV File'

                                $SaveFileName = '{0}_{1}.csv' -f $($ESData.BaseFileName), $(Get-Date -Format yyyyMMdd-HHmmss)
                                $SaveFile     = Join-Path -Path $tmpChecklistPath -ChildPath $SaveFileName
                                $Splat_FormatObject = @{
                                    ScanObject    = $ScanObject
                                    OutputPayLoad = $OutputPayload
                                }
                                If ($ParamList) { $Splat_FormatObject.Add('ParamList', $ParamList) }
                                Format-Object @Splat_FormatObject |
                                    Export-CSV -NoTypeInformation -Path $SaveFile
                            }

                            $Splat_WriteProg = @{
                                Id        = ($ProgressId + 1)
                                ParentId  = $ProgressId
                                Activity  = 'Generating output (CKL/CKLB/CSV/JSON/etc).....'
                                Completed = $true
                            }
                            Write-Progress @Splat_WriteProg
                        }

                        # Add to ScanObjects console or combined checklist output
                        $ScanObjects.Add($ScanObject)
                    }

                    Write-Log @Splat_WriteLog -Type 'Info' -Message 'Removing scan module from memory'
                    [System.GC]::Collect()
                }
                Catch {
                    $errMsgArray = @(
                        "    $($_.Exception.Message)"
                        "    $($_.InvocationInfo.ScriptName)"
                        "    Line: $($_.InvocationInfo.ScriptLineNumber)"
                        "    $(($_.InvocationInfo.Line).Trim())"
                        'Continuing Processing'
                    )
                    Write-Log @Splat_WriteLog -Type 'Error' -Message $errMsg
                    [System.GC]::Collect()
                }
            }
            # ++++++++++++++++++++++ End processing ++++++++++++++++++++++

            # Cleanup connections to VCenter/ESXi Appliances
            If (($VCenterAppliances | Measure-Object).Count -gt 0) {
                Write-Log @Splat_WriteLog -Type 'Info' -Message "Disconnecting from vSphere vCenter: $VCenterAppliances"
                Disconnect-VSphereHost -Appliance $VCenterAppliances
            }
            If (($ESXiAppliances | Measure-Object).Count -gt 0) {
                Write-Log @Splat_WriteLog -Type 'Info' -Message "Disconnecting from vSphere ESXi Host: $ESXiAppliances"
                Disconnect-VSphereHost -Appliance $ESXiAppliances
            }

            # Create combined checklists
            If (($Output -split ",").Trim() -match "(^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)") {
                $Splat_WriteProg = @{
                    Id              = $ProgressId
                    Activity        = $ProgressActivity
                    Status          = 'Generating combined output file(s)'
                    PercentComplete = ($CurrentMainStep / $TotalMainSteps * 100)
                }
                Write-Progress @Splat_WriteProg
                $CurrentMainStep++
                Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash
                Switch ( ($Output -split ',').trim() ) {
                    "(^CombinedCKL$)"  {
                        Write-Log @Splat_WriteLog -Type 'Info' -Message 'Creating combined CKL file'

                        # Set combined checklist filename
                        If ($SelectVuln) {
                            $SaveFileNameTemplate = 'Partial_{0}_COMBINED_{1}.ckl'
                        } Else {
                            $SaveFileNameTemplate = '{0}_COMBINED_{1}.ckl'
                        }
                        $SaveFileName = $SaveFileNameTemplate -f $MachineName, $(Get-Date -Format yyyyMMdd-HHmmss)
                        $SaveFile     = Join-Path -Path $tmpChecklistPath -ChildPath $SaveFileName
                        $Splat_FormatCKL = @{
                            SchemaPath   = $Checklist_xsd
                            ScanObject   = $ScanObjects
                            OutputPath   = $SaveFile
                            Marking      = $Marking
                            WorkingDir   = $WorkingDir
                            ESPath       = $PScriptRoot
                            OSPlatform   = $OSPlatform
                            LogComponent = $LogComponent
                        }
                        $null = Format-CKL @Splat_FormatCKL
                    }
                    "(^CombinedCKLB$)" {
                        Write-Log @Splat_WriteLog -Type 'Info' -Message 'Creating combined CKLB file'

                        # Set combined checklist filename
                        If ($SelectVuln) {
                            $SaveFileNameTemplate = 'Partial_{0}_COMBINED_{1}.cklb'
                        } Else {
                            $SaveFileNameTemplate = '{0}_COMBINED_{1}.cklb'
                        }
                        $SaveFileName = $SaveFileNameTemplate -f $MachineName, $(Get-Date -Format yyyyMMdd-HHmmss)
                        $SaveFile     = Join-Path -Path $tmpChecklistPath -ChildPath $SaveFileName
                        $Splat_FormatCKL = @{
                            SchemaPath   = $Checklist_json
                            ScanObject   = $ScanObjects
                            OutputPath   = $SaveFile
                            Marking      = $Marking
                            WorkingDir   = $WorkingDir
                            ESPath       = $PScriptRoot
                            OSPlatform   = $OSPlatform
                            LogComponent = $LogComponent
                        }
                        $null = Format-CKLB @Splat_FormatCKL
                    }
                    "(^CombinedCSV$)"  {
                        Write-Log @Splat_WriteLog -Type 'Info' -Message 'Creating combined CSV file'

                        # Set combined checklist filename
                        If ($SelectVuln) {
                            $SaveFileNameTemplate = 'Partial_{0}_COMBINED_{1}.ckl'
                        } Else {
                            $SaveFileNameTemplate = '{0}_COMBINED_{1}.ckl'
                        }
                        $SaveFileName = $SaveFileNameTemplate -f $MachineName, $(Get-Date -Format yyyyMMdd-HHmmss)
                        $SaveFile     = Join-Path -Path $tmpChecklistPath -ChildPath $SaveFileName

                        $Splat_FormatObject = @{ ScanObject = $ScanObjects; OutputPayLoad = $OutputPayload }
                        If ($ParamList) { $Splat_FormatObject.Add('ParamList', $ParamList) }
                        Format-Object @Splat_FormatObject |
                            Export-CSV -NoTypeInformation -Path $SaveFile
                    }
                }
            }

            # Handle failure
            If ($FailedCheck -eq $true) {
                $URL_Issue = 'https://spork.navsea.navy.mil/nswc-crane-division/evaluate-stig/-/issues'
                $errMsg    = 'Please report issues to {0}' -f $URL_Issue
                Write-Log @Splat_WriteLog -Type 'Error' -Message $errMsg -WriteOutToStream
            }

            # Send results to STIG Manager
            If (($Output -split ',').Trim() -match "(^STIGManager$)") {
                Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash
                $Splat_WriteProg = @{
                    Id              = $ProgressId
                    Activity        = $ProgressActivity
                    Status          = 'Importing to STIG Manager'
                    PercentComplete = ($CurrentMainStep / $TotalMainSteps * 100)
                }
                Write-Progress @Splat_WriteProg
                $CurrentMainStep++

                Try {
                    $Splat_SMParam = @{
                        SMCollection  = $SMCollection
                        OutputPayLoad = $OutputPayload
                        ScanObject    = $ScanObjects
                        ScriptRoot    = $PSScriptRoot
                        WorkingDir    = $WorkingDir
                        OSPlatform    = $OSPlatform
                        LogComponent  = $LogComponent
                        LogPath       = $STIGLog
                    }
                    If ($SMPassphrase) { $Splat_SMParam['SMPassphrase'] = $SMPassphrase }
                    $SMImport_Params = Get-SMParameters @Splat_SMParam
                    Import-Asset @SMImport_Params
                }
                Catch {
                    Write-Log @Splat_WriteLog -Type 'Error' -Message "ERROR: $($_.Exception.Message)"
                }
            }

            # Send results to Splunk
            If (($Output -split ',').Trim() -match "(^Splunk$)") {
                Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash
                $Splat_WriteProg = @{
                    Id              = $ProgressId
                    Activity        = $ProgressActivity
                    Status          = 'Importing to Splunk'
                    PercentComplete = ($CurrentMainStep / $TotalMainSteps * 100)
                }
                Write-Progress @Splat_WriteProg
                $CurrentMainStep++

                Try {
                    $Splat_SplunkParams = @{
                        SplunkHECName = $SplunkHECName
                        OutputPayLoad = $OutputPayload
                        ScanObject    = $ScanObjects
                        ScriptRoot    = $PSScriptRoot
                        WorkingDir    = $WorkingDir
                        OSPlatform    = $OSPlatform
                        LogComponent  = $LogComponent
                        LogPath       = $STIGLog
                    }
                    $Splunk_Params = Get-SplunkParameters @Splat_SplunkParams
                    Import-Event @Splunk_Params
                }
                Catch {
                    Write-Log @Splat_WriteLog -Type 'Error' -Message "ERROR: $($_.Exception.Message)"
                }
            }

            # Generate Summary Report
            If (($Output -split ',').Trim() -match "(^Summary$)") {
                Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash
                $Splat_WriteProg = @{
                    Id              = $ProgressId
                    Activity        = $ProgressActivity
                    Status          = 'Generating summary report'
                    PercentComplete = ($CurrentMainStep / $TotalMainSteps * 100)
                }
                Write-Progress @Splat_WriteProg
                $CurrentMainStep++

                $Splat_WriteSummaryReport = @{
                    ScanResult    = $ScanObjects
                    OutputPath    = $tmpResultsPath
                    ProcessedUser = $UserToProcess.Username
                    Detail        = $true
                    OSPlatform    = $OSPlatform
                    ScanStartDate = $ScanStartDate
                    ScanType      = $ScanType
                }
                If ($Marking) { $Splat_WriteSummaryReport['Marking'] = $Marking}
                Write-SummaryReport @Splat_WriteSummaryReport

                # Create Summary HTML
                $SummaryFile = Join-Path -Path $tmpResultsPath -ChildPath 'SummaryReport.xml'
                $TempSR = [System.Xml.XmlDocument]::new()

                [void]$TempSR.AppendChild($TempSR.CreateElement('Summaries'))
                $summary = [System.Xml.XmlDocument]::new()
                $summary.Load($SummaryFile)
                $ImportedSummary = $TempSR.ImportNode($Summary.DocumentElement, $true)
                [void]$TempSR.DocumentElement.AppendChild($ImportedSummary)

                $TempSRSummaries.Summary.Results.Result | Foreach-Object {
                    # Build STIG name
                    $STIGName = '{0} V{1}R{2}' -f $($_.STIG -replace '_', ' '), $($_.Version), $($_.Release)
                    If ($_.Site)     { $STIGName = $STIGName + " ($($_.Site))" }
                    If ($_.Instance) { $STIGName = $STIGName + " ($($_.Instance))" }
                    $_.SetAttribute('STIG', $STIGName)
                    $_.SetAttribute('StartTime', [String]($_.StartTime -replace "\.\d+", ""))
                    $CurrentScoreNode = $_.AppendChild($TempSR.CreateElement('CurrentScore'))
                    $CurrentScore = ([int]$_.CAT_I.NotAFinding + [int]$_.CAT_II.NotAFinding + [int]$_.CAT_III.NotAFinding + [int]$_.CAT_I.Not_Applicable + [int]$_.CAT_II.Not_Applicable + [int]$_.CAT_III.Not_Applicable) / ([int]$_.CAT_I.Total + [int]$_.CAT_II.Total + [int]$_.CAT_III.Total)
                    $CurrentScoreNode.SetAttribute("Score", $CurrentScore)
                }
                $TempSR.Save($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml))

                $SummaryReportXLST = New-Object System.XML.Xsl.XslCompiledTransform
                $SummaryReportXLST.Load($(Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath SummaryReport.xslt))
                $SummaryReportXLST.Transform($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml), $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html))

                if ($Marking) {
                    # Add Marking Header and Footer
                    $SRHTML = $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html)
                    (Get-Content $SRHTML) -replace "<body>", "<body>`n    <header align=`"center`">$Marking</header>" | Set-Content $SRHTML

                    Add-Content $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html) "<footer align=`"center`">$Marking</footer>"
                }
            }

            # Move results to ResultsPath
            Write-Log @Splat_WriteLog -Type 'Info' -Message '-' -TemplateMessage LineBreak-Dash
            Write-Log @Splat_WriteLog -Type 'Info' -Message "Copying output files to: $ResultsPath"
            Get-ChildItem -Path $tmpResultsPath -Recurse | Foreach-Object {
                If ($_.PSIsContainer) {
                    if (-not (Test-Path -Path $(Join-Path $ResultsPath -ChildPath $_.Name))) {
                        $null = New-Item -Path $(Join-Path $ResultsPath -ChildPath $_.Name) -ItemType Directory
                    }
                } Else {
                    $DestFolderName  = $_.DirectoryName -ireplace [regex]::Escape($tmpResultsPath), ""
                    $DestinationPath = Join-Path -Path $ResultsPath -ChildPath $DestFolderName
                    Copy-Item -Path $_.FullName -Destination $DestinationPath
                }
            }

            # Apply Tattoo
            If ($ApplyTattoo) {
                Write-Log @Splat_WriteLog -Type 'Info' -Message 'Applying Evaluate-STIG tattoo'
                $TattooHT = @{
                    Version = $ESVersion
                    LastRun = $(Get-Date -Format FileDateTime)
                }
                Switch ($OSPlatform) {
                    'Windows' {
                        # Mark the registry with EvaluateSTIGVersion. This can be used with Endpoint Mgmt tools such as SCCM/MCM detection method.
                        $RegistryPath = 'HKLM:\SOFTWARE\Evaluate-STIG'
                        If (-not (Test-Path -Path $RegistryPath)) { $null = New-Item -Path $RegistryPath -Force }
                        $TattooHT | ForEach-Object {
                            $msg = 'Creating {0} value under "{1}"' -f $_.Key, $RegistryPath
                            Write-Log @Splat_WriteLog -Type 'Info' -Message $msg
                            $Splat_NewItemProp = @{
                                Path         = $RegistryPath
                                Name         = $($_.Key)
                                Value        = $($_.Value)
                                PropertyType = 'String'
                                Force        = $true
                            }
                            New-ItemProperty @Splat_NewItemProp
                        }
                    }
                    'Linux' {
                        $TattooFilePath = '/etc/Evaluate-STIG'
                        $TattooHT | ForEach-Object {
                            $msg = 'Creating {0} value under "{1}"' -f $_.Key, $RegistryPath
                            Write-Log @Splat_WriteLog -Type 'Info' -Message $msg
                            "$($_.Key): $($_.Value)" | Out-File -FilePath $TattooFilePath -Append
                        }
                    }
                }
            }

            # Clean-up
            $Splat_WriteProg = @{
                Id              = $ProgressId
                Activity        = $ProgressActivity
                Status          = 'Finalizing and cleaning-up'
                PercentComplete = ($CurrentMainStep / $TotalMainSteps * 100)
            }
            Write-Progress @Splat_WriteProg
            Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent

            # Finalize log and get totals
            $TimeToComplete = New-TimeSpan -Start $StartTime -End (Get-Date)
            $FormattedTime  = '{0:c}' -f $TimeToComplete

            Write-Log @Splat_WriteLog -Type 'Info' -Message 'Done!' -WriteOutToStream -FGColor Green
            Write-Log @Splat_WriteLog -Type 'Info' -Message "Total Time : $($FormattedTime)" -WriteOutToStream -FGColor Green

            If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^CSV$|^CombinedCSV$)") {
                $ExtensionsToCount = @('.ckl', 'cklb', 'csv')
                $TotalChecklists = Get-ChildItem -Path "$(Join-Path -Path $ResultsPath -ChildPath 'Checklist')" |
                    Where-Object {$_.Extension -in $ExtensionsToCount} |
                    Measure-Object |
                    Select-Object -ExpandProperty Count

                Write-Log @Splat_WriteLog -Type 'Info' -Message "Total checklists in Results Directory : $($TotalChecklists)" -WriteOutToStream -FGColor Green
                Write-Host ''
                Write-Host 'Results saved to:' -ForegroundColor Green -NoNewline
                Write-Host "$($ResultsPath)" -ForegroundColor Cyan
            }
            Write-Log @Splat_WriteLog -Type 'Info' -Message "Exiting with exit code '$ExitCode'"
            Write-Log @Splat_WriteLog -Type 'Info' -Message 'End local logging' -TemplateMessage LineBreak-Text

            If ($Marking) {
                Write-Log @Splat_WriteLog -Type 'Info' -Message $(Out-CenterString -Text $Marking)
            }
            Write-Host ""

            # Copy Evaluate-STIG.log to ResultsPath
            If ($isFormattedOutputRegexMatch) {
                Copy-Item $STIGLog -Destination $ResultsPath -Force -ErrorAction Stop
            }

            # Complete progress bar
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed

            # Output to Console
            If (($Output -split ",").Trim() -match "(^Console$)") {
                # Build ScanResult
                $ScanResult = @{}
                $ScanResult.Add($MachineName, $ScanObjects)
            }
        }
        #endregion VMWare Scan
        #region Local Scan
        Else {
            #####################################################
            # Scan local system
            #####################################################
            $Global:ScanStartDate = (Get-Date -Format "MM/dd/yyyy")

            # OS dependent prerequiste checks
            Switch ($OSPlatform) {
                "Windows" {
                    # Confirm elevated session
                    $isAdmin = Test-IsAdministrator
                    If (-not ($isAdmin) -and -not ($AltCredential) -and ($LinuxList.Count -eq 0)) {
                        $ExitCode = 5
                        throw "You must run this from an elevated PowerShell session or use -AltCredential."
                    }

                    # Check Windows version.  Windows version 6.1 or greater required.
                    # https://docs.microsoft.com/en-us/windows/win32/sysinfo/operating-system-version
                    If ([Version](Get-CimInstance Win32_OperatingSystem).Version -lt "6.1") {
                        $ExitCode = 1
                        Throw "$((Get-CimInstance Win32_OperatingSystem).Version) is not supported.  Must be version 6.1 or greater.  Cannot continue."
                    }

                    # Confirm native PowerShell session
                    $OSArch = (Get-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name PROCESSOR_ARCHITECTURE).PROCESSOR_ARCHITECTURE
                    If ($OSArch -eq "AMD64") {
                        If ([IntPtr]::Size -ne "8") {
                            $ExitCode = 1
                            Throw "32-Bit PowerShell session detected.  Evaluate-STIG must be ran in 64-Bit PowerShell on 64-Bit systems."
                        }
                    }
                }
                "Linux" {
                    # Confirm we have an elevated session.
                    If ((id -u) -ne 0) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session."
                    }

                    # Check for prerequisites
                    $null = lshw -version 2>/dev/null
                    $null = dmidecode --version 2>/dev/null
                    $null = bc -version 2>/dev/null

                    if ($ComputerName) {
                        $ExitCode = 1
                        Throw "Remote computer option supports Windows only."
                    }
                }
            }

            # Test OutputPath connectivity
            If ($OutputPath -and -not (Test-Path -Path $OutputPath)) {
                $ExitCode = 5
                throw "'$OutputPath' is NOT accessible by '$([Environment]::Username)' on '$MachineName'."
            }

            # Set variables
            Switch ($OSPlatform) {
                "Windows" {
                    $Global:WorkingDir = "$env:windir\Temp\Evaluate-STIG"
                    $DomainRole = (Get-DomainRoleStatus).RoleFriendlyName
                    $HiveFile = "$($WorkingDir)\Eval-STIG_UserHive.dat" # Copy of user's registry hive
                    $ES_Hive_Tasks = @("Eval-STIG_SaveHive", "Eval-STIG_LoadHive", "Eval-STIG_UnloadHive") # Potential scheduled tasks for user hive actions
                }
                "Linux" {
                    $Global:WorkingDir = "/tmp/Evaluate-STIG"
                    $Release = Get-Content /etc/os-release
                    If ($release | Select-String "Workstation") {
                        $DomainRole = "Member Workstation"
                    }
                    ElseIf ($release | Select-String "Server") {
                        $DomainRole = "Member Server"
                    }
                    Else {
                        $DomainRole = "Member Workstation"
                    }
                }
            }
            $MachineName = ($(Get-FullHostName).FullName).ToUpper()
            If ($OutputPath) {
                If ($SelectVuln) {
                    $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath "_Partial_$MachineName"
                }
                Else {
                    $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath $MachineName
                }
            }
            $StartTime = Get-Date
            $Date = Get-Date -Format yyyyMMdd
            $Global:STIGLog = Join-Path -Path $WorkingDir -ChildPath "Evaluate-STIG.log"
            [int]$Global:TotalMainSteps = 1
            [int]$Global:CurrentMainStep = 1
            [int]$Global:ProgressId = 1
            if ($Marking) {
                $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Marking: $Marking | Answer Key: $AnswerKey)"
            }
            else {
                $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Answer Key: $AnswerKey)"
            }

            # Create WorkingDir
            If (-Not(Test-Path $WorkingDir)) {
                $null = New-Item $WorkingDir -ItemType Directory
            }

            # Check/Create lock file
            If (Test-Path (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck)) {
                $ProcLockInfo = Get-Content (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction Stop
                If ($ProcLockInfo) {
                    Try {
                        If (Get-Process -Name $ProcLockInfo.split("`r`n")[0] -ErrorAction SilentlyContinue | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                            $ExitCode = 33
                            Throw "Evaluate-STIG is currently processing from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])"
                        }
                    }
                    Catch {
                        Write-Host $_.Exception.Message -ForegroundColor Red -BackgroundColor Black
                        Exit $ExitCode
                    }
                }
            }
            $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
            Set-Content -Path (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

            # ++++++++++++++++++++++ Begin processing ++++++++++++++++++++++
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Initializing and generating list of required STIGs"

            If (Test-Path $STIGLog) {
                Remove-Item $STIGLog -Force
            }

            If ($Marking) {
                Write-Log -Path $STIGLog -Message "                                                                                          $Marking                                                                                          " -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            Write-Log -Path $STIGLog -Message "Begin Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Reconstruct command line for logging purposes
            $CommandLine = Get-CommandLine -CommandName "Evaluate-STIG.ps1" -BoundParameters $PSBoundParameters

            Write-Log -Path $STIGLog -Message "Executing: $($CommandLine)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # If a file block detected, log it.
            If ($FileBlock -eq $true) {
                Write-Log -Path $STIGLog -Message "File detected with the block attribute set.  Please run Test-Prerequisites.bat to correct." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
            }

            $InUsePrefs | ForEach-Object {
                Write-Log -Path $STIGLog -Message "Utilizing Preference: $($_) $($Preferences.Preferences.EvaluateSTIG.$_)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            If (($Output -split ",").Trim() -match "(^CSV$|^CombinedCSV$|^Splunk$)" -or $JSON) {
                Write-Log -Path $STIGLog -Message "Utilizing Output Payload: $($OutputPayload -join ",")" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Verify Evaluate-STIG files integrity
            $FileIntegrityPass = $true
            Write-Log -Path $STIGLog -Message "Verifying Evaluate-STIG file integrity" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If (Test-Path (Join-Path -Path $PSScriptRoot -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")) {
                [XML]$FileListXML = Get-Content -Path (Join-Path -Path $PSScriptRoot -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")
                $FileListValid = Test-XmlSignature -checkxml $FileListXML -Force
                Switch ($FileListValid) {
                    $true {
                        $Verified = $true
                        $XccdfFailedHash = @()
                        ForEach ($File in ($FileListXML.FileList.File | Where-Object ScanReq -ne "NotRequired")) {
                            $Path = (Join-Path -Path $PsScriptRoot -ChildPath $File.Path | Join-Path -ChildPath $File.Name)
                            If (Test-Path $Path) {
                                If ((Get-FileHash -Path $Path -Algorithm SHA256).Hash -ne $File.SHA256Hash) {
                                    $FileIntegrityPass = $false
                                    $Verified = $false
                                    If ($File.Name -like "*xccdf.xml") {
                                        $XccdfFailedHash += $File.Name
                                    }
                                    Write-Log -Path $STIGLog -Message "WARNING: '$($Path)' failed integrity check." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                                }
                            }
                            Else {
                                If ($File.ScanReq -eq "Required") {
                                    $Verified = $false
                                    Write-Log -Path $STIGLog -Message "ERROR: '$($File.Name)' is a required file but not found.  Scan results may be incomplete." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                }
                            }
                        }
                        If ($Verified -eq $true) {
                            Write-Log -Path $STIGLog -Message "Evaluate-STIG file integrity check passed." -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Else {
                            Write-Log -Path $STIGLog -Message "WARNING: One or more Evaluate-STIG files failed integrity check." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                    }
                    $false {
                        $FileIntegrityPass = $false
                        Write-Log -Path $STIGLog -Message "ERROR: 'FileList.xml' failed authenticity check.  Unable to verify content integrity." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    DEFAULT {
                        $FileIntegrityPass = $false
                        Write-Log -Path $STIGLog -Message "ERROR: Test-XmlSignature on 'FileList.xml' failed with the following message:" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message $FileListValid -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                }
            }
            Else {
                $ExitCode = 2
                Throw "'FileList.xml' not found."
            }
            If ($FileIntegrityPass -ne $true) {
                If ($AllowIntegrityViolations -ne $true) {
                    $ExitCode = 1
                    Throw "File integrity checks failed - refer to $STIGLog.  Aborting scan"
                }
                Else {
                    Write-Log -Path $STIGLog -Message "-AllowIntegrityViolations specified so continuing with scan." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                }
            }

            # Schema Files
            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $AnswerFile_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_AnswerFile.xsd"
            $Checklist_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "U_Checklist_Schema_V2.xsd"
            $Checklist_json = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "CKLB.schema.json"
            If (-Not(Test-Path $STIGList_xsd)) {
                $ExitCode = 2
                Throw "'$STIGList_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $AnswerFile_xsd)) {
                $ExitCode = 2
                Throw "'$AnswerFile_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $Checklist_xsd)) {
                $ExitCode = 2
                Throw "'$Checklist_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $Checklist_json)) {
                $ExitCode = 2
                Throw "'$Checklist_json' - file not found."
            }

            # STIGList.xml validation
            $XmlFile = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                $ExitCode = 2
                Throw "'$XmlFile' - file not found."
            }
            Else {
                $Result = Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd
                If ($Result -ne $true) {
                    ForEach ($Item in $Result.Message) {
                        Write-Log -Path $STIGLog -Message $Item -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    $ExitCode = 1
                    Throw "'$($XmlFile)' failed XML validation"
                }
            }

            Write-Log -Path $STIGLog -Message "Evaluate-STIG Version: $ESVersion" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Launching User: $([Environment]::Username)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Pre-checks passed.  Begin processing.
            # =====================================
            # Get AssetData
            $AssetData = Get-AssetData -OSPlatform $OSPlatform

            # Begin: Get single IPv4/MAC for CKL usage [issue 1999]
            Try {
                If ($IsLinux -and (Get-Command -Name nslookup -ErrorAction SilentlyContinue)) {
                    $NsLookup = (nslookup $AssetData.FQDN -type=a)
                    $ResolvedIP = & {
                        $i = 0
                        ForEach ($Line in $NsLookup) {
                            If ($Line -match $AssetData.FQDN) {
                                Return ($NsLookup[$i + 1] -replace "Address:").Trim()
                            }
                            Else {
                                $i++
                            }
                        }
                    }
                }
                Else {
                    $ResolvedIP = (Resolve-DnsName -Name $AssetData.FQDN -Type A -DnsOnly -NoRecursion -QuickTimeout -ErrorAction SilentlyContinue | Select-Object -First 1).IPAddress
                }
            }
            Catch {
                # Do nothing
            }

            If ($ResolvedIP) {
                # Get adapter that ResolvedIP is configured
                $PrimaryAdapter = $AssetData.ActiveAdapters | Where-Object {$_.IPv4Address -contains $ResolvedIP}
            }

            If (-Not($PrimaryAdapter)) {
                If ($AssetData.ActiveAdapters) {
                    # No adapter with ResolvedIP found so get the first by InterfaceIndex
                    $PrimaryAdapter = ($AssetData.ActiveAdapters | Sort-Object InterfaceIndex)[0]
                }
            }

            If ($PrimaryAdapter) {
                $PrimaryIpAddress = $PrimaryAdapter.IPv4Address | Where-Object {$_ -eq $ResolvedIP}
                If (-Not($PrimaryIpAddress)) {
                    # No configured IP matching ResolvedIP found so get the first IP
                    If (($PrimaryAdapter.IPv4Address | Measure-Object).Count -gt 1) {
                        $PrimaryIpAddress = $PrimaryAdapter.IPv4Address[0]
                    }
                    Else {
                        $PrimaryIpAddress = $PrimaryAdapter.IPv4Address
                    }
                }

                If (($PrimaryAdapter.MACAddress | Measure-Object).Count -gt 1) {
                    $PrimaryMacAddress = $PrimaryAdapter.MACAddress[0]
                }
                Else {
                    $PrimaryMacAddress = $PrimaryAdapter.MACAddress
                }
            }
            Else {
                $PrimaryIpAddress = ""
                $PrimaryMacAddress = ""
            }# End: Get single IPv4/MAC for CKL usage [issue 1999]

            # Write configuration data to log
            Write-Log -Path $STIGLog -Message "Hostname: $MachineName" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Manufacturer: $($AssetData.Manufacturer)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Model: $($AssetData.Model)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Operating System Platform: $OSPlatform" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Operating System Name: $($AssetData.OSName)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Operating System Version: $($AssetData.OSVersion)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Operating System Architecture: $($AssetData.OSArchitecture)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Domain Role: $DomainRole" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Primary IP Address: $PrimaryIPAddress" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Primary MAC Address: $PrimaryMacAddress" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "PowerShell Version: $PowerShellVersion" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Scan Type: $ScanType" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Answer Key: $AnswerKey" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Answer File Path: $AFPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Results Path: $ResultsPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # --- Begin Answer File validation
            Write-Log -Path $STIGLog -Message "Validating answer files" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            $AnswerFileList = New-Object System.Collections.Generic.List[System.Object]
            $XmlFiles = Get-ChildItem -Path $AFPath | Where-Object Extension -EQ ".xml"

            # Verify answer files for proper format
            ForEach ($Item in $XmlFiles) {
                $Validation = (Test-XmlValidation -XmlFile $Item.FullName -SchemaFile $AnswerFile_xsd)
                If ($Validation -eq $true) {
                    Write-Log -Path $STIGLog -Message "$($Item.Name) : Passed" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    [XML]$Content = Get-Content $Item.FullName
                    If ($Content.STIGComments.Name) {
                        $NewObj = [PSCustomObject]@{
                            STIG          = $Content.STIGComments.Name
                            Name          = $Item.Name
                            FullName      = $Item.FullName
                            LastWriteTime = $Item.LastWriteTime
                        }
                        $AnswerFileList.Add($NewObj)
                    }
                }
                Else {
                    Write-Log -Path $STIGLog -Message "ERROR: $($Item.Name) : Answer file failed schema validation and will be ignored.  Please correct or remove." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "$($Validation.Message)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            $AnswerFileList = $AnswerFileList | Sort-Object LastWriteTime -Descending
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            # --- End Answer File validation

            # Build list of required STIGs
            Write-Log -Path $STIGLog -Message "Gathering list of STIGs applicable to this system" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            $DetectedSTIGs = Get-ApplicableProducts -ES_Path $PsScriptRoot -AllowDeprecated:$true -NoProgress

            [XML]$STIGList = Get-Content (Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml")
            $STIGsToProcess = [System.Collections.Generic.List[System.Object]]::new()
            If ($SelectSTIG) {
                ForEach ($Node in ($STIGList.List.STIG | Where-Object {$OSPlatform -in ($_.ApplicableOS -split ",").Trim() -and $_.AssetType -eq "Other"})) {
                    If ($Node.ShortName -in $SelectSTIG) {
                        If ($Node.ShortName -in $DetectedSTIGs.ShortName) {
                            If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName)}) {
                                    $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName)})[0]
                                }
                                Else {
                                    $AFtoUse = ""
                                }

                                # Determine deprecation
                                $Deprecated = $false
                                If ($Node.DisaStatus -eq "Deprecated") {
                                    $Deprecated = $true
                                }

                                $NewObj = [PSCustomObject]@{
                                    Name           = $Node.Name
                                    Shortname      = $Node.ShortName
                                    StigContent    = $Node.StigContent
                                    AnswerFile     = $AFtoUse
                                    PsModule       = $Node.PsModule
                                    PsModuleVer    = $Node.PsModuleVer
                                    UserSettings   = $Node.UserSettings
                                    CanCombine     = $Node.CanCombine
                                    Classification = $Node.Classification
                                    CklTechArea    = $Node.CklTechArea
                                    Deprecated     = $Deprecated
                                    Forced         = $false
                                }
                                $STIGsToProcess.Add($NewObj)
                            }
                        }
                        ElseIf ($Node.Shortname -notin $ForceSTIG) {
                            Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' requested with -SelectSTIG but is not applicable to this system so will be ignored." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                    }
                }
            }
            Else {
                ForEach ($Node in ($STIGList.List.STIG | Where-Object {$OSPlatform -in ($_.ApplicableOS -split ",").Trim() -and $_.AssetType -eq "Other"})) {
                    If ($Node.DisaStatus -eq "Deprecated" -and -Not($AllowDeprecated)) {
                        # Ignore deprecated STIG
                    }
                    Else {
                        If ($Node.ShortName -in $DetectedSTIGs.ShortName) {
                            If ($Node.Shortname -in $ExcludeSTIG -and $Node.Shortname -notin $ForceSTIG) {
                                Write-Log -Path $STIGLog -Message "WARNING: '$($Node.Name)' is applicable to this system but has been excluded from scan with the -ExcludeSTIG option." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                            Else {
                                If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                    If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName)}) {
                                        $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName)})[0]
                                    }
                                    Else {
                                        $AFtoUse = ""
                                    }

                                    # Determine deprecation
                                    $Deprecated = $false
                                    If ($Node.DisaStatus -eq "Deprecated") {
                                        $Deprecated = $true
                                    }

                                    $NewObj = [PSCustomObject]@{
                                        Name           = $Node.Name
                                        Shortname      = $Node.ShortName
                                        StigContent    = $Node.StigContent
                                        AnswerFile     = $AFtoUse
                                        PsModule       = $Node.PsModule
                                        PsModuleVer    = $Node.PsModuleVer
                                        UserSettings   = $Node.UserSettings
                                        CanCombine     = $Node.CanCombine
                                        Classification = $Node.Classification
                                        CklTechArea    = $Node.CklTechArea
                                        Deprecated     = $Deprecated
                                        Forced         = $false
                                    }
                                    $STIGsToProcess.Add($NewObj)
                                }
                            }
                        }
                    }
                }
            }

            # Add any forced STIGs to scan
            If ($ForceSTIG) {
                $ManualSTIGsToProcess = [System.Collections.Generic.List[System.Object]]::new()
                foreach ($ManualSTIG in $((Get-ChildItem $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath "Manual") | Where-Object Extension -EQ ".xml"))) {
                    [xml]$Content = Get-Content $ManualSTIG.FullName
                    $ManualSTIGName = $Content.Benchmark.ID
                    $ManualSTIGShortname = "M_" + $($ManualSTIGName -replace "_", "" -replace "STIG", "")

                    If ($ManualSTIGShortname -in $ForceSTIG){
                        if ($STIGList.List.STIG | Where-Object StigContent -EQ $ManualSTIG.Name){
                            Write-Log -Path $STIGLog -Message "Manual scan for '$($ManualSTIGShortname)' requested with -ForceSTIG but is already supported. Ignoring." -WriteOutToStream -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        else{
                            Switch -Regex ($Content.'xml-stylesheet') {
                                'STIG_unclass.xsl' {
                                    $Classification = "UNCLASSIFIED"
                                }
                                'STIG_cui.xsl' {
                                    $Classification = "CUI"
                                }
                                DEFAULT {
                                    $Classification = "No match in 'xml-stylesheet'."
                                }
                            }

                            If ($AnswerFileList | Where-Object {($_.STIG -eq $ManualSTIGShortname)}) {
                                $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $ManualSTIGShortname)})[0]
                            }
                            Else {
                                $AFtoUse = ""
                            }
                            $NewObj = [PSCustomObject]@{
                                Name           = $ManualSTIGName
                                Shortname      = $ManualSTIGShortname
                                StigContent    = $ManualSTIG.Name
                                AnswerFile     = $AFtoUse
                                PsModule       = "Manual"
                                PsModuleVer    = "0.0.0.0"
                                UserSettings   = "false"
                                CanCombine     = "false"
                                Classification = $Classification
                                CklTechArea    = "Other Review"
                                Deprecated     = $false
                                Forced         = $true
                            }
                            $ManualSTIGsToProcess.Add($NewObj)
                            Write-Log -Path $STIGLog -Message "Manual scan for '$($ManualSTIGShortname)' requested with -ForceSTIG. Adding to STIGs to process." -WriteOutToStream -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                    }
                }
                ForEach ($STIG in $ForceSTIG) {
                    If ($STIG -notin $STIGsToProcess.ShortName) {
                        if ($STIGList.List.STIG | Where-Object ShortName -EQ $STIG){
                            $Node = $STIGList.List.STIG | Where-Object ShortName -EQ $STIG
                            If (($STIGList.List.STIG | Where-Object ShortName -EQ $STIG).AssetType -notin @('Other')) {
                                Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' requested with -ForceSTIG but cannot be performed in this context. Ignoring." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                            Else {
                                If ($Node.ShortName -notin $DetectedSTIGs.ShortName) {
                                    $Forced = $true
                                    Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' forced with -ForceSTIG.  Evaluate-STIG results are not guaranteed with this option.  Use at own risk." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                                }
                                Else {
                                    $Forced = $false
                                }
                                If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                    If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName)}) {
                                        $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName)})[0]
                                    }
                                    Else {
                                        $AFtoUse = ""
                                    }

                                    # Determine deprecation
                                    $Deprecated = $false
                                    If ($Node.DisaStatus -eq "Deprecated") {
                                        $Deprecated = $true
                                    }

                                    $NewObj = [PSCustomObject]@{
                                        Name           = $Node.Name
                                        Shortname      = $Node.ShortName
                                        StigContent    = $Node.StigContent
                                        AnswerFile     = $AFtoUse
                                        PsModule       = $Node.PsModule
                                        PsModuleVer    = $Node.PsModuleVer
                                        UserSettings   = $Node.UserSettings
                                        CanCombine     = $Node.CanCombine
                                        Classification = $Node.Classification
                                        CklTechArea    = $Node.CklTechArea
                                        Deprecated     = $Deprecated
                                        Forced         = $Forced
                                    }
                                    $STIGsToProcess.Add($NewObj)
                                }
                            }
                        }
                        else{
                            $NewObj = $ManualSTIGsToProcess | Where-Object {$_.Shortname -eq $STIG}
                            $STIGsToProcess.Add($NewObj)
                        }
                    }
                }
            }
            [int]$TotalMainSteps = $TotalMainSteps + ($STIGsToProcess | Measure-Object).Count

            # Note ApplicableSTIGs in log (deprecated are not considered applicable given they no longer exist on cyber.mil)
            Write-Log -Path $STIGLog -Message "The following STIGs are determined applicable:" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            ForEach ($STIG in ($DetectedSTIGs | Where-Object DISAStatus -NE "Deprecated") | Sort-Object Name) {
                Write-Log -Path $STIGLog -Message "STIG: $($STIG.Name)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            $ApplicableSTIGs = @()
            ForEach ($Item in ($DetectedSTIGs | Where-Object DISAStatus -NE "Deprecated")) {
                $ApplicableSTIGs += ($STIGList.List.STIG | Where-Object ShortName -eq $Item.ShortName)
            }

            # If no supported STIGs are applicable, log it and exit
            If (($STIGsToProcess | Measure-Object).Count -eq 0) {
                Write-Log -Path $STIGLog -Message "WARNING: No Evaluate-STIG supported STIGs are applicable to this system." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform

                # Clean up
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent
                Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                # Complete progress bar
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed

                If ($PSStyleBackup) {
                    # Restore $PSStyle settings
                    $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                    $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
                }

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
                [System.GC]::Collect()
                Start-Sleep -Seconds 1

                # Exit with code
                Exit $ExitCode
            }
            Else {
                Write-Log -Path $STIGLog -Message "STIGs to process - $(($STIGsToProcess | Measure-Object).count)" -WriteOutToStream -FGColor Magenta -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            # Write list of STIGs that will be evaluated to log
            Write-Log -Path $STIGLog -Message "The following STIGs will be evaluated:" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            ForEach ($STIG in $STIGsToProcess | Sort-Object Name) {
                $AnswerFileMsg = ""
                If ($STIG.AnswerFile) {
                    $AnswerFileMsg = "  |  AnswerFile: $($STIG.AnswerFile.Name) (Modified: $(Get-Date (Get-ChildItem $STIG.AnswerFile.FullName).LastWriteTime -Format "dd MMM yyyy HH:mm:ss"))"
                }

                If ($STIG.Deprecated -eq $true) {
                    Write-Log -Path $STIGLog -Message "STIG: $($STIG.Name) [Deprecated]$($AnswerFileMsg)" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                }
                Else {
                    Write-Log -Path $STIGLog -Message "STIG: $($STIG.Name)$($AnswerFileMsg)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                }
            }
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Confirm STIG specific prerequisites are met
            If ($STIGsToProcess.Name -like "IIS *") {
                If (-Not(Powershell.exe -NoProfile -Command {Get-Module -ListAvailable -Name "WebAdministration"})) {
                    Write-Log -Path $STIGLog -Message "ERROR: 'WebAdministration' module is not available to PowerShell. IIS checklists will not be generated." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    $STIGsToIgnore = $STIGsToProcess | Where-Object Name -Like "IIS *"
                    ForEach ($Obj in $STIGsToIgnore) {
                        If ($Obj -in $STIGsToProcess) {
                            [Void]$STIGsToProcess.Remove($Obj)
                        }
                    }
                }
            }

            # Test connectivity to OutputPath and create folder for computer
            Try {
                If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)") {
                    If (-Not(Test-Path $ResultsPath)) {
                        $null = New-Item $ResultsPath -ItemType Directory -ErrorAction Stop
                        Start-Sleep 5
                    }
                }
            }
            Catch {
                Write-Log -Path $STIGLog -Message "ERROR: Failed to create output path '$($ResultsPath)'" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                $ExitCode = 1
                Throw $_
            }

            # Remove orphaned objects
            Write-Log -Path $STIGLog -Message "Checking for and removing orphaned objects from a previous scan" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Switch ($OSPlatform) {
                "Windows" {
                    # Remove existing Evaluate-STIG_UserHive in case it exists
                    If (Test-Path Registry::HKU\Evaluate-STIG_UserHive) {
                        [System.GC]::Collect()
                        Start-Sleep -Seconds 1
                        Try {
                            Start-Sleep -Seconds 5
                            Write-Log -Path $STIGLog -Message "Removing orphaned object: HKU:\Evaluate-STIG_UserHive" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $Result = Start-Process -FilePath REG -ArgumentList "UNLOAD HKU\Evaluate-STIG_UserHive" -Wait -PassThru -WindowStyle Hidden
                            If ($Result.ExitCode -ne 0) {
                                Throw # and attempt as SYSTEM
                            }
                        }
                        Catch {
                            # REG command failed so attempt to do as SYSTEM
                            Write-Log -Path $STIGLog -Message "WARNING: Failed to unload hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            Try {
                                $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[2] -FilePath REG -ArgumentList "UNLOAD HKU\Evaluate-STIG_UserHive" -MaxRunInMinutes 1
                                If ($Result.LastTaskResult -ne 0) {
                                    Throw $Result
                                }
                            }
                            Catch {
                                $ExitCode = $Result.LastTaskResult
                                Throw "Failed to unload user hive."
                            }
                        }
                    }

                    # Remove orphaned scheduled tasks
                    If (Get-Command -Name Get-ScheduledTask -ErrorAction SilentlyContinue) {
                        $Tasks = (Get-ScheduledTask | Where-Object TaskName -In $ES_Hive_Tasks).TaskName
                        If ($Tasks) {
                            ForEach ($Item in $Tasks) {
                                Unregister-ScheduledTask -TaskName $Item -Confirm:$false -ErrorAction SilentlyContinue
                            }
                        }
                    }
                    Else {
                        ForEach ($Item in $ES_Hive_Tasks) {
                            $Task = ((SCHTASKS /Query /TN $Item /V /FO List 2>$null))
                            If ($Task) {
                                $null = SCHTASKS /Delete /TN $Item /F
                            }
                        }
                    }
                }
                "Linux" {
                    # TBD
                }
            }

            $TempFiles = Get-Item -Path $WorkingDir\* -Exclude Evaluate-STIG.log, Evaluate-STIG.lck -Force
            If ($TempFiles) {
                ForEach ($Item in $TempFiles) {
                    Write-Log -Path $STIGLog -Message "Removed orphaned object: $($Item.FullName)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $null = Remove-Item -Path $Item.FullName -Recurse -Force -ErrorAction Stop
                }
            }

            # Increase TotalMainSteps based on options/STIGs
            If (($Output -split ",").Trim() -match "(^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^STIGManager$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^Splunk$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^Summary$)") {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match "(^OQE$)") {
                $TotalMainSteps++
            }

            If ($STIGsToProcess | Where-Object UserSettings -EQ $true) {
                $TotalMainSteps++
            }

            # OS dependent steps
            If ($OSPlatform -eq "Windows") {
                $ExtFilesRequired = $false
                ForEach ($Item in $STIGsToProcess.ShortName) {
                    # Add STIG ShortNames that need an external file for processing (SecPol.ini, AppLocker.ini, Evaluate-STIG_FilesToScan.txt, etc)
                    If ($Item -in @("DotNET4", "IIS10Server", "IIS85Server", "Win7", "Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022", "WinServerDNS", "JBoss")) {
                        $ExtFilesRequired = $true
                    }
                }
                If ($ExtFilesRequired -eq $true) {
                    $TotalMainSteps++
                }

                # =========== Determine User to Evaluate ===========
                If ($STIGsToProcess | Where-Object UserSettings -EQ $true) {
                    Write-Log -Path $STIGLog -Message "Determining which user to evaluate for HKCU items" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Determining user to evaluate and importing registry hive" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    $CurrentMainStep++

                    # Get all profile paths and find which ntuser.pol was most recently updated.
                    $UserToProcess = Get-UsersToEval -ProvideSingleUser
                    If ($UserToProcess) {
                        Write-Log -Path $STIGLog -Message "Will evaluate $($UserToProcess.Username) for user-based settings" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    ProfileType: $($UserToProcess.ProfileType)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        If ($UserToProcess.LastPolicyUpdate -eq "Never") {
                            Write-Log -Path $STIGLog -Message "    LastPolicyUpdate: $($UserToProcess.LastPolicyUpdate)" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                        Else {
                            Write-Log -Path $STIGLog -Message "    LastPolicyUpdate: $($UserToProcess.LastPolicyUpdate) ($((New-TimeSpan -Start $UserToProcess.LastPolicyUpdate -End (Get-Date)).Days) days ago)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Write-Log -Path $STIGLog -Message "    SID: $($UserToProcess.SID)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    LocalPath: $($UserToProcess.LocalPath)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    ProfileLoadTime: $($UserToProcess.ProfileLoadTime)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    NTUserDatPath: $($UserToProcess.NTUserDatPath)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    NTUserDatUpdate: $($UserToProcess.NTUserDatUpdate)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        If ($UserToProcess.Preferred) {
                            Write-Log -Path $STIGLog -Message "    Preferred: $($UserToProcess.Preferred)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Else {
                            Write-Log -Path $STIGLog -Message "    Preferred: $($UserToProcess.Preferred)" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                    }
                    Else {
                        Write-Log -Path $STIGLog -Message "WARNING: No scannable user profile found.  Will evaluate .DEFAULT profile for user-based settings" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        $UserToProcess = @{
                            UserName = ".DEFAULT"
                            SID      = ".DEFAULT"
                        }
                    }

                    # =========== Export and Load User Registry Hive ===========
                    If (Test-Path -Path Registry::HKU\$($UserToProcess.SID)) {
                        # User hive is currently loaded so we must save the loaded hive as we cannot copy NTUSER.DAT due to in use.
                        Try {
                            Write-Log -Path $STIGLog -Message "User's hive is currently loaded into the registry.  Saving HKU:\$($UserToProcess.SID) to $($HiveFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $Result = Start-Process -FilePath REG -ArgumentList "SAVE HKU\$($UserToProcess.SID) $($HiveFile) /y /c" -Wait -PassThru -WindowStyle Hidden
                            If ($Result.ExitCode -ne 0) {
                                Throw # and attempt as SYSTEM
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message "WARNING: Failed to save hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            # REG command failed so attempt to do as SYSTEM
                            Try {
                                If (Test-Path $HiveFile) {
                                    Remove-Item $HiveFile -Force
                                }
                                $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[0] -FilePath REG -ArgumentList "SAVE HKU\$($UserToProcess.SID) $($HiveFile) /y /c" -MaxRunInMinutes 1
                                If ($Result.LastTaskResult -ne 0) {
                                    Throw $Result
                                }
                            }
                            Catch {
                                $ExitCode = $Result.LastTaskResult
                                Throw "Failed to save user hive."
                            }
                        }
                    }
                    Else {
                        # User hive is not currently so we we will make a copy the user's NTUSER.DAT for importing
                        Write-Log -Path $STIGLog -Message "User's hive not found in registry.  Copying $($UserToProcess.NTUserDatPath) to $($HiveFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Copy-Item "$($UserToProcess.NTUserDatPath)" -Destination $HiveFile -Force -ErrorAction Stop
                    }

                    # Load the copied/saved user hive into HKU for parsing
                    Try {
                        Write-Log -Path $STIGLog -Message "Loading $($HiveFile) into HKU:\Evaluate-STIG_UserHive" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $Result = Start-Process -FilePath REG -ArgumentList "LOAD HKU\Evaluate-STIG_UserHive $($HiveFile)" -Wait -PassThru -WindowStyle Hidden
                        If ($Result.ExitCode -ne 0) {
                            Throw # and attempt as SYSTEM
                        }
                    }
                    Catch {
                        Write-Log -Path $STIGLog -Message "WARNING: Failed to load hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        # REG command failed so attempt to do as SYSTEM
                        Try {
                            $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[1] -FilePath REG -ArgumentList "LOAD HKU\Evaluate-STIG_UserHive $($HiveFile)" -MaxRunInMinutes 1
                            If ($Result.LastTaskResult -ne 0) {
                                Throw $Result
                            }
                        }
                        Catch {
                            $ExitCode = $Result.LastTaskResult
                            Throw "Failed to load user hive."
                        }
                    }
                }
                Else {
                    # Set UserName and SID to "NA"
                    $UserToProcess = @{
                        UserName = "NA"
                        SID      = "NA"
                    }
                }

                # =========== Create External Reference Files ===========
                If ($ExtFilesRequired -eq $true) {
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Creating temporary export files for enumeration" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    $CurrentMainStep++

                    # AppLocker
                    ForEach ($Item in $STIGsToProcess.ShortName) {
                        If ($Item -in @("Win7", "Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022")) {
                            $AppLockerRequired = $true
                        }
                    }
                    If ($AppLockerRequired -eq $true) {
                        Try {
                            Write-Log -Path $STIGLog -Message "Collecting AppLocker effective policy and saving to $($WorkingDir)\$($AppLockerPolFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $AppLockerPolFile = "AppLockerPol_$(${env:computername})_$($Date).xml"
                            If (($PsVersionTable.PSVersion -join ".") -lt [Version]"7.0") {
                                Import-Module AppLocker
                            }
                            Else {
                                Import-Module AppLocker -SkipEditionCheck
                            }
                            Get-AppLockerPolicy -Effective -Xml -ErrorAction Stop | Out-File $WorkingDir\$($AppLockerPolFile) -Force
                        }
                        Catch {
                            $AppLockerRequired = $false
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }

                    # Security Policy
                    ForEach ($Item in $STIGsToProcess.ShortName) {
                        If ($Item -in @("Win7", "Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022", "WinServerDNS", "JBoss")) {
                            $SecPolRequired = $true
                        }
                    }
                    If ($SecPolRequired -eq $true) {
                        Write-Log -Path $STIGLog -Message "Exporting security policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $SecPolFileName = "Evaluate-STIG_SecPol.ini"
                        Start-Process -FilePath secedit.exe -ArgumentList "/export /cfg $($WorkingDir)\$($SecPolFileName)" -Wait -WindowStyle Hidden
                    }

                    # List of files to be scanned based on STIGs to evaluate
                    $FileExtensionsForScan = @()
                    $FilesToScan = @()
                    ForEach ($Item in $STIGsToProcess) {
                        Switch -Regex ($Item.ShortName) {
                            "^DotNET4$" {
                                $FileSearchReq = $true

                                If ($SelectVuln -or $ExcludeVuln) {
                                    $HashArguments = @{
                                        ModulePath = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule))
                                    }
                                    If ($SelectVuln) {
                                        $HashArguments.Add("SelectVuln", $SelectVuln)
                                    }
                                    If ($ExcludeVuln) {
                                        $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                                    }

                                    $FileSearchReq = Test-IsFileSearchRequired @HashArguments
                                }

                                If ($FileSearchReq) {
                                    # STIG requires *.exe.config
                                    $FileExtensionsForScan += "*.exe.config"

                                    # And machine.config files
                                    $FilesToScan += "$env:SYSTEMROOT\Microsoft.NET\Framework\v4.0.30319\Config\machine.config"
                                    If ((Get-CimInstance Win32_OperatingSystem).OSArchitecture -eq "64-bit") {
                                        $FilesToScan += "$env:SYSTEMROOT\Microsoft.NET\Framework64\v4.0.30319\Config\machine.config"
                                    }
                                }
                            }
                            "(^Win\d+$|^WinServer\d+\w*$)" {
                                $FileSearchReq = $true

                                If ($SelectVuln -or $ExcludeVuln) {
                                    $HashArguments = @{
                                        ModulePath = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule))
                                    }
                                    If ($SelectVuln) {
                                        $HashArguments.Add("SelectVuln", $SelectVuln)
                                    }
                                    If ($ExcludeVuln) {
                                        $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                                    }

                                    $FileSearchReq = Test-IsFileSearchRequired @HashArguments
                                }

                                If ($FileSearchReq) {
                                    # STIG requires *.p12 and *.pfx
                                    $FileExtensionsForScan += "*.p12"
                                    $FileExtensionsForScan += "*.pfx"
                                }
                            }
                            "^IIS\d+Server$" {
                                $FileSearchReq = $true

                                If ($SelectVuln -or $ExcludeVuln) {
                                    $HashArguments = @{
                                        ModulePath = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule))
                                    }
                                    If ($SelectVuln) {
                                        $HashArguments.Add("SelectVuln", $SelectVuln)
                                    }
                                    If ($ExcludeVuln) {
                                        $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                                    }

                                    $FileSearchReq = Test-IsFileSearchRequired @HashArguments
                                }

                                If ($FileSearchReq) {
                                    # STIG requires *.java and *.jpp
                                    $FileExtensionsForScan += "*.java"
                                    $FileExtensionsForScan += "*.jpp"
                                }
                            }
                        }
                    }
                    If ($FileExtensionsForScan) {
                        Try {
                            Write-Log -Path $STIGLog -Message "Collecting list of $($FileExtensionsForScan -join '|') files  to $($WorkingDir)\Evaluate-STIG_FilesToScan.txt" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting list of $($FileExtensionsForScan -join '|') files..."

                            # Run file search in runspace to enforce timeout
                            $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                            $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                            $SessionState.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList 'FileExtensionsForScan', $FileExtensionsForScan, ''))
                            $SessionState.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList 'FilesToScan', $FilesToScan, ''))
                            $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                            $RunspacePool.Open()
                            $Command = '
                                # Get hard disk drive letters
                                $WMIDisks = (Get-CimInstance Win32_LogicalDisk | Where-Object DriveType -EQ 3).DeviceID
                                $Drives = (Get-PSDrive -PSProvider FileSystem | Where-Object {$_.DisplayRoot -eq $null -and $_.Root.TrimEnd("\") -in $WMIDisks}).Root

                                # Search each hard drive for required file extensions
                                ForEach ($Drive in $Drives) {
                                    $FilesToScan += Search-Files -Path $Drive -File $FileExtensionsForScan -ExcludePath @("$env:windir\CSC", "$env:windir\WinSxS", "$env:windir\servicing")
                                }

                                # Save inventory to disk for scan reference
                                $FilesToScan | Where-Object {$_ -ne ""} | Out-File $env:windir\Temp\Evaluate-STIG\Evaluate-STIG_FilesToScan.txt -Force
                            '
                            $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout $FileSearchTimeout -RunspacePool $RunspacePool
                            If ($Result.Keys -contains "CodeFail") {
                                Throw "CodeFail"
                            }
                            $RunspacePool.Close()
                            $RunspacePool.Dispose()
                        }
                        Catch {
                            If ($_.Exception.Message -match "timed out") {
                                Write-Log -Path $STIGLog -Message "FileSearchTimeout of '$FileSearchTimeout' minutes reached.  Checks requiring scan for file types will not be completed.  Consider increasing the timeout with -FileSearchTimeout." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                            ElseIf ($_.Exception.Message -eq "CodeFail") {
                                # Failure detected in command code
                                $ErrorData = $Result.ErrorData | Get-ErrorInformation
                                If ($STIGLog -and (Test-Path $STIGLog)) {
                                    ForEach ($Prop in ($ErrorData.PSObject.Properties).Name) {
                                        Write-Log -Path $STIGLog -Message "$($Prop) : $($ErrorData.$Prop)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                    }
                                }
                            }
                            Else {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }
                            $RunspacePool.Close()
                            $RunspacePool.Dispose()
                        }
                    }
                }
            }
            Else {
                # Set UserName and SID to "NA"
                $UserToProcess = @{
                    UserName = whoami
                    SID      = "NA"
                }
            }

            # =========== Run the scans ===========
            If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)") {
                # $tmpResultsPath is needed for all filetype Outputs
                $tmpResultsPath = $(Join-Path -Path $WorkingDir -ChildPath "Results")
                If (-Not(Test-Path $tmpResultsPath)) {
                    $null = New-Item -Path $tmpResultsPath -ItemType Directory
                }
            }

            $ApplicableSTIGsCount = [System.Collections.Generic.List[System.Object]]::new()
            $ProcessedSTIGs = [System.Collections.Generic.List[System.Object]]::new()
            $ScanObjects = [System.Collections.Generic.List[System.Object]]::new()
            $ScanJobs = [System.Collections.Generic.List[System.Object]]::new()
            # Get STIG instance counts and build list of jobs to be ran
            $STIGsToDetect = [System.Collections.Generic.List[System.Object]]::new()
            ForEach ($Item in $STIGsToProcess) {
                $STIGsToDetect.Add($Item)
            }
            ForEach ($Item in $ApplicableSTIGs) {
                If ($Item.ShortName -notin $STIGsToDetect.ShortName) {
                    $NewObj = [PSCustomObject]@{
                        Name           = $Item.Name
                        Shortname      = $Item.ShortName
                        StigContent    = $Item.StigContent
                        AnswerFile     = ""
                        PsModule       = $Item.PsModule
                        PsModuleVer    = $Item.PsModuleVer
                        UserSettings   = $Item.UserSettings
                        CanCombine     = $Item.CanCombine
                        Classification = $Item.Classification
                        CklTechArea    = $Item.CklTechArea
                        Deprecated     = $Deprecated
                        Forced         = $false
                    }
                    $STIGsToDetect.Add($NewObj)
                }
            }

            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Getting instance counts and building job list"
            Write-Log -Path $STIGLog -Message "Getting instance counts and building job list" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            ForEach ($Item in ($STIGsToDetect | Sort-Object Name)) {
                Try {
                    # Create subjobs object for STIGs that may apply multiple times (IIS, SQL, etc.)
                    $SubJobs = [System.Collections.Generic.List[System.Object]]::new()

                    # Set path to STIG .xccdf.xml and get needed data from it
                    If (Test-Path $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath $Item.StigContent)){
                        # Temporarily import scan module for access to custom functions
                        If ($PowerShellVersion -lt [Version]"7.0") {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule)) -ErrorAction Stop
                        }
                        Else {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule)) -SkipEditionCheck -ErrorAction Stop
                        }
                        $StigXmlPath = $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath $Item.StigContent)
                    }
                    Else {
                        $StigXmlPath = $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath "Manual" | Join-Path -ChildPath $Item.StigContent)
                    }
                    $STIGID = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.ID).Trim()
                    $STIGTitle = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Title).Trim()
                    $STIGVer = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Version).Trim()
                    $STIGRel = ((((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.'plain-text' | Where-Object { $_.id -eq "release-info" }).'#text' -split 'Benchmark')[0].Trim() -split ' ')[1].Trim()
                    $STIGDate = (((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.'plain-text' | Where-Object { $_.id -eq "release-info" }).'#text' -split 'Date:')[1].Trim()
                    $STIGVersion = "V$($STIGVer)R$($STIGRel)"
                    $STIGStyleSheet = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).'xml-stylesheet').Trim()
                    # Set STIG Classification
                    Switch -Regex ($STIGStyleSheet) {
                        'STIG_unclass.xsl' {
                            $Classification = "UNCLASSIFIED"
                        }
                        'STIG_cui.xsl' {
                            $Classification = "CUI"
                        }
                        DEFAULT {
                            $Classification = "No match in 'xml-stylesheet'."
                        }
                    }

                    $STIGTargetKey = (Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Group[0].Rule.reference.identifier

                    # Build STIGInfo Object
                    $STIGInfo = [ordered]@{
                        STIGID         = $STIGID
                        Title          = $STIGTitle
                        Version        = $STIGVer
                        Release        = $STIGRel
                        ReleaseDate    = $STIGDate
                        Classification = $Classification
                        EvalScore      = 0
                        CATI_OpenNRTotal   = 0
                        CATII_OpenNRTotal  = 0
                        CATIII_OpenNRTotal = 0
                    }

                    # Build TargetData Object
                    Switch -Regex ($AssetData.Role) {
                        "Workstation" {
                            $Role = "Workstation"
                        }
                        "Server" {
                            $Role = "Member Server"
                        }
                        "Domain Controller" {
                            $Role = "Domain Controller"
                        }
                        DEFAULT {
                            $Role = $AssetData.Role
                        }
                    }

                    $TargetData = [ordered]@{
                        Marking        = $Marking
                        Hostname       = $AssetData.HostName
                        IpAddress      = $PrimaryIpAddress
                        MacAddress     = $PrimaryMacAddress
                        FQDN           = $AssetData.FQDN
                        TargetComments = $TargetComments
                        Role           = $Role
                        CklTechArea    = $Item.CklTechArea
                    }
                    $TargetData.Add("TargetKey", $STIGTargetKey)
                    $TargetData.Add("WebOrDatabase", $false) # Initialize 'WebOrDatabase'.  If required, set below.
                    $TargetData.Add("Site", "")              # Initialize 'Site'.  If required, set below.
                    $TargetData.Add("Instance", "")          # Initialize 'Instance'.  If required, set below.

                    $STIGData = @{
                        StigXmlPath = $StigXmlPath
                        StigVersion = $STIGVersion
                        Name        = $Item.Name
                        ShortName   = $Item.ShortName
                        PsModule    = $Item.PsModule
                        CanCombine  = $Item.CanCombine
                    }

                    # Set parameters for Invoke-STIGScan
                    $ScanArgs = @{
                        StigXmlPath           = $StigXmlPath
                        VulnTimeout           = $($VulnTimeout)
                        SelectVuln            = $SelectVuln
                        ExcludeVuln           = $ExcludeVuln
                        Deprecated            = $Item.Deprecated
                        AllowSeverityOverride = $AllowSeverityOverride
                        Forced                = $Item.Forced
                        ModulesPath           = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules")
                        PsModule              = $Item.PsModule
                        LogPath               = $STIGLog
                        LogComponent          = $LogComponent
                        OSPlatform            = $OSPlatform
                        ProgressId            = $ProgressId
                        ModuleArgs            = @{} # Initialze ModuleArgs object
                    }

                    # Set common arguments for scan module.  Additional variables and parameters may be added.
                    $ScanArgs.ModuleArgs.Add("ScanType", $ScanType)
                    if ($Item.AnswerFile.FullName) {
                        $ScanArgs.ModuleArgs.Add("AnswerFile", "'$($Item.AnswerFile.FullName)'")
                    }
                    else {
                        $ScanArgs.ModuleArgs.Add("AnswerFile", "")
                    }
                    $ScanArgs.ModuleArgs.Add("AnswerKey", $AnswerKey)
                    $ScanArgs.ModuleArgs.Add("Username", $UserToProcess.Username)
                    $ScanArgs.ModuleArgs.Add("UserSID", $UserToProcess.SID)
                    $ScanArgs.ModuleArgs.Add("ESVersion", $ESVersion)
                    $ScanArgs.ModuleArgs.Add("LogPath", $STIGLog)
                    $ScanArgs.ModuleArgs.Add("OSPlatform", $OSPlatform)
                    $ScanArgs.ModuleArgs.Add("LogComponent", $LogComponent)

                    # Build list of variables to be exposed to answer files.  Additional variables can be added per STIG when required.
                    $AnswerFileVars = @{
                        ESPath   = $PSScriptRoot
                        Hostname = $AssetData.HostName
                        Username = $UserToProcess.Username
                        UserSID  = $UserToProcess.SID
                        Instance = ""
                        Database = ""
                        Site  = ""
                    }
                    $ScanArgs.ModuleArgs.Add("AnswerFileVars", $AnswerFileVars)

                    # Determine additional arguments execute scan
                    Switch ($Item.ShortName) {
                        {$_ -in @("Apache24SiteUnix", "Apache24SiteWin")} {
                            Try {
                                # Get all the instances of apache running and their relevant information.
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'Get-ApacheInstances'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $ApacheInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("ApacheInstance", $null)
                                $ScanArgs.ModuleArgs.Add("VirtualHost", $null)
                                $ScanArgs.ModuleArgs.Add("SiteName", "")

                                ForEach ($instance in $ApacheInstances) {
                                    $ScanArgs.ModuleArgs.ApacheInstance = $instance
                                    ForEach ($vhost in $instance.VirtualHosts) {
                                        $ScanArgs.ModuleArgs.VirtualHost = $vhost
                                        If ($vhost.Index -eq -1) {
                                            $ScanArgs.ModuleArgs.SiteName = ("BaseConfig-" + $instance.Index)
                                        }
                                        Else {
                                            $ScanArgs.ModuleArgs.SiteName = ($vhost.SiteName + "-" + $vhost.SitePort)
                                        }

                                        # Set output filename
                                        $BaseFileName = Format-BaseFileName -HostName $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.SiteName -STIGVersion $STIGData.StigVersion

                                        # Update TargetData
                                        $TargetData.WebOrDatabase = $true
                                        $TargetData.Site = $ScanArgs.ModuleArgs.SiteName
                                        $TargetData.Instance = ""

                                        # Add to AnswerFileVars
                                        $ScanArgs.ModuleArgs.AnswerFileVars.Site = $TargetData.Site

                                        # Build and add sub job
                                        $NewObj = [PSCustomObject]@{
                                            BaseFileName = $BaseFileName
                                            STIGInfo     = $STIGInfo
                                            TargetData   = (Get-DeepCopy $TargetData)
                                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                                        }
                                        $SubJobs.Add($NewObj)
                                    }
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        {$_ -in @("Apache24SvrUnix", "Apache24SvrWin")} {
                            Try {
                                # Get all the instances of apache running and their relevant information.
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'Get-ApacheInstances'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $ApacheInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("ApacheInstance", $null)
                                $ScanArgs.ModuleArgs.Add("VirtualHost", $null)
                                $ScanArgs.ModuleArgs.Add("SiteName", "")

                                ForEach ($instance in $ApacheInstances) {
                                    $ScanArgs.ModuleArgs.ApacheInstance = $instance
                                    $ScanArgs.ModuleArgs.SiteName = ("Server-" + $instance.Index)

                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -HostName $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.SiteName -STIGVersion $STIGData.StigVersion

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $ScanArgs.ModuleArgs.SiteName
                                    $TargetData.Instance = ""

                                    # Add to AnswerFileVars
                                    $ScanArgs.ModuleArgs.AnswerFileVars.Site = $TargetData.Site

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        "ArcGIS" {
                            Try {
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'Get-ArcGISInstances'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $ArcGISInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("ArcGISInstance", $null)
                                $ScanArgs.ModuleArgs.Add("Instance", "")

                                ForEach ($instance in $ArcGISInstances) {
                                    $XmlObject = Get-XMLObject -Path $instance.ApplicationHost
                                    if ($null -ne $XmlObject) {
                                        $SiteNames = Get-ArcGISSites -XmlObject $XmlObject
                                        if (($SiteNames | Measure-Object).Count -eq 1) {
                                            $SiteName = $SiteNames.name
                                        }
                                        else {
                                            $SiteName = ($SiteNames[0]).name
                                        }

                                        $FileSiteName = $SiteName -replace " ", "_"
                                    }
                                    else {
                                        $SiteName = $("Server-" + $instance.Index)
                                    }
                                    $ScanArgs.ModuleArgs.ArcGISInstance = $instance
                                    $ScanArgs.ModuleArgs.Instance = ($SiteName)

                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -HostName $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $FileSiteName -STIGVersion $STIGData.StigVersion

                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $($ScanArgs.ModuleArgs.Instance)
                                    $TargetData.Instance = ""

                                    # Add to AnswerFileVars
                                    $ScanArgs.ModuleArgs.AnswerFileVars.Site = $TargetData.Site

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        "MSOffice365" {
                            Try {
                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("InstalledO365Apps", $(Get-InstalledO365Apps))

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                            Catch {
                                Throw $_
                            }
                        }
                        {$_ -in @("IIS10Site", "IIS85Site")} {
                            Try {
                                $AllSites = PowerShell.exe -NoProfile -Command {Import-Module WebAdministration; Get-WebSite | Select-Object Name}

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("SiteName", "")

                                ForEach ($Site in $Allsites) {
                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $Site.Name -STIGVersion $STIGData.StigVersion

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $Site.Name
                                    $TargetData.Instance = ""

                                    # Set SiteName in module arguments
                                    $ScanArgs.ModuleArgs.SiteName = "'$($Site.Name)'"

                                    # Add to AnswerFileVars
                                    $ScanArgs.ModuleArgs.AnswerFileVars.Site = $TargetData.Site

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                            Catch {
                                Throw $_
                            }
                        }
                        "JBoss" {
                            Try {
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'Get-JBossInstances'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $JBossInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("JBossInstance", $null)
                                $ScanArgs.ModuleArgs.Add("Instance", "")

                                ForEach ($instance in $JBossInstances) {
                                    $ScanArgs.ModuleArgs.JBossInstance = $instance
                                    $ScanArgs.ModuleArgs.Instance = $instance.Server

                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.Instance -STIGVersion $STIGData.StigVersion

                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = ""
                                    $TargetData.Instance = $($Instance.Name)

                                    # Add to AnswerFileVars
                                    $ScanArgs.ModuleArgs.AnswerFileVars.Instance = $TargetData.Instance

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        "TrellixENS10xLocal" {
                            Try {
                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("EnsConfig", $(Get-EnsConfig))

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                            Catch {
                                Throw $_
                            }
                        }
                        "ApacheTomcatAS" {
                            Try {
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'Get-TomcatInstances'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $TomcatInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("TomcatInstance", $null)
                                $ScanArgs.ModuleArgs.Add("Instance", "")

                                ForEach ($instance in $TomcatInstances) {
                                    $ScanArgs.ModuleArgs.TomcatInstance = $instance
                                    $ScanArgs.ModuleArgs.Instance = "$($instance.Bindings)"

                                    if (($instance.Bindings | Measure-Object).Count -eq 1) {
                                        $InstanceFileName = $instance.Bindings
                                    }
                                    else {
                                        $InstanceFileName = $instance.Bindings[0]
                                    }
                                    $InstanceFileName = $InstanceFileName -replace ':', '-'

                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $InstanceFileName -STIGVersion $STIGData.StigVersion

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $($ScanArgs.ModuleArgs.Instance)
                                    $TargetData.Instance = ""

                                    # Add to AnswerFileVars
                                    $ScanArgs.ModuleArgs.AnswerFileVars.Site = $TargetData.Site

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        {$_ -in @("SQL2014Instance", "SQL2016Instance", "SQL2022Instance")} {
                            Try {
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()

                                if ($_ -in $ForceSTIG) {
                                    $Command = 'Get-AllInstances'
                                }
                                else {
                                    Switch ($_) {
                                        "SQL2014Instance" {
                                            $Command = 'Get-AllInstances | Where-Object {[Version]$_.Version -like "12.*"}'
                                        }
                                        "SQL2016Instance" {
                                            $Command = 'Get-AllInstances | Where-Object {[Version]$_.Version -like "1[345].*"}'
                                        }
                                        "SQL2022Instance" {
                                            $Command = 'Get-AllInstances | Where-Object {[Version]$_.Version -ge "16.0"}'
                                        }
                                    }
                                } # if ($_ -in $ForceSTIG)
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $allInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("Instance", "")
                                $ScanArgs.ModuleArgs.Add("Database", "")

                                ForEach ($Instance in $allInstances) {
                                    If ($Instance.Status -eq "Running") {
                                        # Set output filename
                                        $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $Instance.Name -STIGVersion $STIGData.StigVersion

                                        # Update TargetData
                                        $TargetData.WebOrDatabase = $true
                                        $TargetData.Site = ""
                                        $TargetData.Instance = $($Instance.Name)

                                        # Set Instance and Database in module arguments
                                        $ScanArgs.ModuleArgs.Instance = "'$($Instance.Name)'"
                                        $ScanArgs.ModuleArgs.Database = "master"

                                        # Add to AnswerFileVars
                                        $ScanArgs.ModuleArgs.AnswerFileVars.Instance = $TargetData.Instance

                                        # Build and add sub job
                                        $NewObj = [PSCustomObject]@{
                                            BaseFileName = $BaseFileName
                                            STIGInfo     = $STIGInfo
                                            TargetData   = (Get-DeepCopy $TargetData)
                                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                                        }
                                        $SubJobs.Add($NewObj)
                                    }
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        {$_ -in @("SQL2014DB", "SQL2016DB", "SQL2022DB")} {
                            Try {
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                if ($_ -in $ForceSTIG) {
                                    $Command = 'Get-AllInstances'
                                }
                                else {
                                    Switch ($_) {
                                        "SQL2014DB" {
                                            $Command = 'Get-AllInstances | Where-Object {[Version]$_.Version -like "12.*"}'
                                        }
                                        "SQL2016DB" {
                                            $Command = 'Get-AllInstances | Where-Object {[Version]$_.Version -like "1[345].*"}'
                                        }
                                        "SQL2022DB" {
                                            $Command = 'Get-AllInstances | Where-Object {[Version]$_.Version -ge "16.0"}'
                                        }
                                    }
                                } # if ($_ -in $ForceSTIG)
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $allInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("Instance", "")
                                $ScanArgs.ModuleArgs.Add("Database", "")
                                ForEach ($Instance in $allInstances) {
                                    If ($Instance.Status -eq "Running") {
                                        $allDatabases = (Get-ISQL -ServerInstance $Instance.Name -qry "select name from sys.databases where state = 0 order by 1").Name
                                        ForEach ($Database in $allDatabases) {
                                            # Set output filename
                                            $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $Instance.Name -Database $Database -STIGVersion $STIGData.StigVersion

                                            # Update TargetData
                                            $TargetData.WebOrDatabase = $true
                                            $TargetData.Site = $Database
                                            $TargetData.Instance = $($Instance.Name)

                                            # Set Instance and Database in module arguments
                                            $ScanArgs.ModuleArgs.Instance = "'$($Instance.Name)'"
                                            $ScanArgs.ModuleArgs.Database = "'$Database'"

                                            # Add to AnswerFileVars
                                            $ScanArgs.ModuleArgs.AnswerFileVars.Instance = $TargetData.Instance
                                            $ScanArgs.ModuleArgs.AnswerFileVars.Database = $TargetData.Site

                                            # Build and add sub job
                                            $NewObj = [PSCustomObject]@{
                                                BaseFileName = $BaseFileName
                                                STIGInfo     = $STIGInfo
                                                TargetData   = (Get-DeepCopy $TargetData)
                                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                                            }
                                            $SubJobs.Add($NewObj)
                                        }
                                    }
                                }
                                Close-SQLConnections
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        "SharePoint2013" {
                            Try {
                                Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting configuration for $_..."
                                Write-Log -Path $STIGLog -Message "Collecting configuration for $_" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                                # Get configuration using Powershell 5 due to Powershell 7 incompatability
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'powershell.exe -NoProfile -Command {
                                    Try {
                                        # Import SharePoint snapin
                                        If (-Not(Get-PsSnapIn Microsoft.SharePoint.PowerShell -ErrorAction SilentlyContinue)) {
                                            Add-PsSnapIn Microsoft.SharePoint.PowerShell
                                        }

                                        # Import IIS module
                                        If (-Not(Get-Module -Name WebAdministration)) {
                                            Import-Module WebAdministration
                                        }

                                        # Export SharePoint and IIS configurations
                                        $CustomVars = @{
                                            SPWebApplication = (Get-SPWebApplication -IncludeCentralAdministration)
                                            SPAlternateURL   = (Get-SPAlternateURL)
                                            IISSite          = (Get-IISSite)
                                        }

                                        Return $CustomVars
                                    }
                                    Catch {
                                        Return $_
                                    }
                                }'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 5 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail" -or $Result.Exception) {
                                    Throw "CodeFail"
                                }
                                Else {
                                    # Add CustomVars
                                    $ScanArgs.ModuleArgs.Add("CustomVars", $Result)
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting configuration for $_..." -Completed

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                            Catch {
                                Throw $_
                            }
                        }
                        {$_ -in @("MSExchange2016EdgeTP", "MSExchange2019Edge")} {
                            Try {
                                Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting configuration for $_..."
                                Write-Log -Path $STIGLog -Message "Collecting configuration for $_" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                                # Get configuration using Powershell 5 due to Powershell 7 incompatability
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'powershell.exe -NoProfile -Command {
                                    Try {
                                        # Import Exchange snapin
                                        If (-Not(Get-PsSnapIn Microsoft.Exchange.Management.PowerShell.SnapIn -ErrorAction SilentlyContinue)) {
                                            Add-PsSnapIn Microsoft.Exchange.Management.PowerShell.SnapIn
                                        }

                                        # Export SharePoint and IIS configurations
                                        $CustomVars = @{
                                            AcceptedDomain            = (Get-AcceptedDomain)
                                            AttachmentFilterEntry     = (Get-AttachmentFilterEntry)
                                            ContentFilterConfig       = (Get-ContentFilterConfig)
                                            EventLogLevel             = (Get-EventLogLevel)
                                            ExchangeCertificate       = (Get-ExchangeCertificate -Server $env:COMPUTERNAME | Select-Object CertificateDomains, Subject, Issuer, Services, NotAfter, Thumbprint)
                                            ExchangeServer            = (Get-ExchangeServer)
                                            ExchangeServerStatus      = (Get-ExchangeServer -Status)
                                            IPAllowListConfig         = (Get-IPAllowListConfig)
                                            IPAllowListEntry          = (Get-IPAllowListEntry -Server $env:COMPUTERNAME)
                                            IPBlockListProvider       = (Get-IPBlockListProvider)
                                            OrganizationConfig        = (Get-OrganizationConfig)
                                            ReceiveConnector          = (Get-ReceiveConnector -Server $env:COMPUTERNAME)
                                            RecipientFilterConfig     = (Get-RecipientFilterConfig)
                                            SendConnector             = (Get-SendConnector)
                                            SenderFilterConfig        = (Get-SenderFilterConfig)
                                            SenderIDConfig            = (Get-SenderIDConfig)
                                            SenderReputationConfig    = (Get-SenderReputationConfig)
                                            TransportService          = (Get-TransportService -Identity $env:COMPUTERNAME)
                                            MalwareAgent              = (Get-TransportAgent "Malware Agent")
                                        }

                                        Return $CustomVars
                                    }
                                    Catch {
                                        Return $_
                                    }
                                }'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 5 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail" -or $Result.Exception) {
                                    Throw "CodeFail"
                                }
                                Else {
                                    # Add CustomVars
                                    $ScanArgs.ModuleArgs.Add("CustomVars", $Result)
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting configuration for $_..." -Completed

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                            Catch {
                                Throw $_
                            }
                        }
                        {$_ -in @("MSExchange2016MB", "MSExchange2019MB")} {
                            Try {
                                Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting configuration for $_..."
                                Write-Log -Path $STIGLog -Message "Collecting configuration for $_" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                                # Get configuration using Powershell 5 due to Powershell 7 incompatability
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'powershell.exe -NoProfile -Command {
                                    Try {
                                        # Import Exchange snapin
                                        If (-Not(Get-PsSnapIn Microsoft.Exchange.Management.PowerShell.SnapIn -ErrorAction SilentlyContinue)) {
                                            Add-PsSnapIn Microsoft.Exchange.Management.PowerShell.SnapIn
                                        }

                                        # Export SharePoint and IIS configurations
                                        $CustomVars = @{
                                            AdminAuditLogConfig       = (Get-AdminAuditLogConfig)
                                            ContentFilterConfig       = (Get-ContentFilterConfig)
                                            DatabaseAvailabilityGroup = (Get-DatabaseAvailabilityGroup)
                                            EventLogLevel             = (Get-EventLogLevel)
                                            ExchangeCertificate       = (Get-ExchangeCertificate -Server $env:COMPUTERNAME | Select-Object CertificateDomains, Subject, Issuer, Services, NotAfter, Thumbprint)
                                            ExchangeServer            = (Get-ExchangeServer)
                                            ExchangeServerStatus      = (Get-ExchangeServer -Status)
                                            ForwardingSmtpAddress     = (Get-Mailbox -Server $env:COMPUTERNAME | Select-Object Name, ForwardingSmtpAddress | Where-Object ForwardingSmtpAddress -ne $null)
                                            MailboxDatabase           = (Get-MailboxDatabase -Server $env:COMPUTERNAME)
                                            MalwareFilteringServer    = (Get-MalwareFilteringServer)
                                            OrganizationConfig        = (Get-OrganizationConfig)
                                            OutlookAnywhere           = (Get-OutlookAnywhere -Server $env:COMPUTERNAME)
                                            OwaVirtualDirectory       = (Get-OwaVirtualDirectory -Server $env:COMPUTERNAME)
                                            ReceiveConnector          = (Get-ReceiveConnector -Server $env:COMPUTERNAME)
                                            RemoteDomain              = (Get-RemoteDomain)
                                            RecordsManagementGroup    = (Get-RoleGroup "Records Management" | Get-RoleGroupMember)
                                            RpcClientAccess           = (Get-RpcClientAccess -Server $env:COMPUTERNAME)
                                            SendConnector             = (Get-SendConnector)
                                            SenderFilterConfig        = (Get-SenderFilterConfig)
                                            SenderIDConfig            = (Get-SenderIDConfig)
                                            SenderReputationConfig    = (Get-SenderReputationConfig)
                                            MalwareAgent              = (Get-TransportAgent "Malware Agent")
                                            TransportConfig           = (Get-TransportConfig)
                                            TransportService          = (Get-TransportService -Identity $env:COMPUTERNAME)
                                        }

                                        Return $CustomVars
                                    }
                                    Catch {
                                        Return $_
                                    }
                                }'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 5 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail" -or $Result.Exception) {
                                    Throw "CodeFail"
                                }
                                Else {
                                    # Add CustomVars
                                    $ScanArgs.ModuleArgs.Add("CustomVars", $Result)
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting configuration for $_..." -Completed

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                            Catch {
                                Throw $_
                            }
                        }
                        "MongoDB3" {
                            Try {
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'Get-MongoDBInstances'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $MongoInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("MongoInstance", $null)
                                $ScanArgs.ModuleArgs.Add("Instance", "")
                                $ScanArgs.ModuleArgs.Add("Database", "")

                                ForEach ($instance in $MongoInstances) {
                                    $ScanArgs.ModuleArgs.MongoInstance = $instance
                                    $ScanArgs.ModuleArgs.Instance = ($instance.BindIP + "-" + $instance.BindPort)
                                    $ScanArgs.ModuleArgs.Database = $instance.Database

                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.Instance -STIGVersion $STIGData.StigVersion

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $($instance.BindIP)
                                    $TargetData.Instance = $($instance.Database)

                                    # Add to AnswerFileVars
                                    $ScanArgs.ModuleArgs.AnswerFileVars.Instance = $TargetData.Site
                                    $ScanArgs.ModuleArgs.AnswerFileVars.Database = $TargetData.Instance

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        "PgSQL9x" {
                            Try {
                                # Run detection in runspace to enforce timeout
                                $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath Master_Functions))
                                $SessionState.ImportPSModule($(Join-Path -Path $PSScriptRoot -ChildPath Modules | Join-Path -ChildPath $Item.PsModule))
                                $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 1, $SessionState, $Host)
                                $RunspacePool.Open()
                                $Command = 'Get-PostgreSQLInstances'
                                $Result = Invoke-CodeWithTimeout -CommandString $Command -Timeout 1 -RunspacePool $RunspacePool
                                If ($Result.Keys -contains "CodeFail") {
                                    Throw "CodeFail"
                                }
                                Else {
                                    $PgInstances = $Result
                                }
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()

                                # Add additional module arguments
                                $ScanArgs.ModuleArgs.Add("PGInstance", $null)
                                $ScanArgs.ModuleArgs.Add("Instance", "")
                                $ScanArgs.ModuleArgs.Add("Database", "")

                                ForEach ($instance in $PgInstances) {
                                    If ($instance.PSQLAccess) {
                                        $ScanArgs.ModuleArgs.PGInstance = $instance
                                        $ScanArgs.ModuleArgs.Instance = ($instance.Server + "-" + $instance.Port)
                                        $ScanArgs.ModuleArgs.Database = $instance.Database

                                        # Set output filename
                                        $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.Instance -Database $ScanArgs.ModuleArgs.Database -STIGVersion $STIGData.StigVersion

                                        # Update TargetData
                                        $TargetData.WebOrDatabase = $true
                                        $TargetData.Site = $($instance.Server)
                                        $TargetData.Instance = $($instance.Database)

                                        # Add to AnswerFileVars
                                        $ScanArgs.ModuleArgs.AnswerFileVars.Instance = $TargetData.Site
                                        $ScanArgs.ModuleArgs.AnswerFileVars.Database = $TargetData.Instance

                                        # Build and add sub job
                                        $NewObj = [PSCustomObject]@{
                                            BaseFileName = $BaseFileName
                                            STIGInfo     = $STIGInfo
                                            TargetData   = (Get-DeepCopy $TargetData)
                                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                                        }
                                        $SubJobs.Add($NewObj)
                                    }
                                    Else {
                                        Write-Log -Path $STIGLog -Message "----------------Skipping CKL------------------" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                        Write-Log -Path $STIGLog -Message "ERROR: STIG: $($STIG.Name) PSQL access requirement not met." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        $HbaFile = Join-Path -Path "$($instance.PG_DATA)" -ChildPath "pg_hba.conf"
                                        Write-Log -Path $STIGLog -Message "ERROR: Local trust authentication method must be set in $($HbaFile)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        Write-Log -Path $STIGLog -Message "ERROR: Skipping Server: $($instance.Server), Port: $($instance.Port), Database: $($instance.Database) " -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                    }
                                }
                            }
                            Catch {
                                $RunspacePool.Close()
                                $RunspacePool.Dispose()
                                If ($_.Exception.Message -eq "CodeFail") {
                                    Throw $Result.ErrorData
                                }
                                Else {
                                    Throw $_
                                }
                            }
                        }
                        Default {
                            Try {
                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                            Catch {
                                Throw $_
                            }
                        }
                    }

                    # Add instance count(s) for STIG if deemed applicable
                    If ($Item.ShortName -in $ApplicableSTIGs.ShortName) {
                        $NewObj = [PSCustomObject]@{
                            ShortName        = $Item.ShortName
                            Total            = ($SubJobs | Measure-Object).Count
                            DetectionSuccess = $true
                        }
                        $ApplicableSTIGsCount.Add($NewObj)
                    }

                    # Add scan job if selected for scanning
                    If ($Item.Shortname -in $STIGsToProcess.ShortName) {
                        Write-Log -Path $STIGLog -Message "Creating scan job(s) for $($Item.ShortName)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $NewObj = [PSCustomObject]@{
                            STIGData = $STIGData
                            SubJobs  = $SubJobs
                        }
                        $ScanJobs.Add($NewObj)
                    }

                    # Add STIG to ProcessedSTIGs for AssetData.ScanSummary
                    If ($Item.ShortName -in $STIGsToProcess.ShortName) {
                        $Flags = @()
                        If ($Item.Deprecated) {
                            $Flags += "[Deprecated]"
                        }
                        If ($Item.Forced) {
                            $Flags += "[Forced]"
                        }
                        $NewObj = [PSCustomObject]@{
                            ShortName = $Item.ShortName
                            Flags     = $Flags
                        }
                        $ProcessedSTIGs.Add($NewObj)
                    }

                    If ($item.PsModule -ne "Manual"){
                        # Remove module after adding job to queue.  Will be imported for scan when needed.
                        Remove-Module $Item.PsModule -Force -ErrorAction SilentlyContinue
                    }
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "Unable to process $($Item.ShortName) - skipping" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    $ErrorData = $_ | Get-ErrorInformation
                    If ($STIGLog -and (Test-Path $STIGLog)) {
                        ForEach ($Prop in ($ErrorData.PSObject.Properties).Name) {
                            Write-Log -Path $STIGLog -Message "$($Prop) : $($ErrorData.$Prop)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }

                    # Add a single instance count for STIG if deemed applicable
                    If ($Item.ShortName -in $ApplicableSTIGs.ShortName) {
                        $NewObj = [PSCustomObject]@{
                            ShortName        = $Item.ShortName
                            Total            = 1
                            DetectionSuccess = $false
                        }
                        $ApplicableSTIGsCount.Add($NewObj)
                    }

                    If ($item.PsModule -ne "Manual"){
                        # Remove module.
                        Remove-Module $Item.PsModule -Force -ErrorAction SilentlyContinue
                    }
                }
            }

            # Execute the scans
            $FailedCheck = $false
            ForEach ($Job in $ScanJobs) {
                Try {
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Evaluating STIG: $($Job.STIGData.Name)" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $CurrentMainStep++

                    Write-Log -Path $STIGLog -Message "Invoking scan" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $ModError = ""
                    Try {
                        If ($Job.STIGData.PsModule -ne "Manual"){
                            Write-Log -Path $STIGLog -Message "Importing scan module: $($Job.STIGData.PsModule)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            If ($PowerShellVersion -lt [Version]"7.0") {
                                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Job.STIGData.PsModule)) -ErrorAction Stop
                            }
                            Else {
                                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Job.STIGData.PsModule)) -SkipEditionCheck -ErrorAction Stop
                            }
                            $PsModule = (Get-Module $Job.STIGData.PsModule)
                            Write-Log -Path $STIGLog -Message "Module Version: $($PsModule.Version)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        else{
                            Write-Log -Path $STIGLog -Message "$($Job.STIGData.Name) added manually. No module to import." -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                    }
                    Catch {
                        $ModError = $_.Exception.Message
                    }

                    If ($ModError) {
                        # If module failed to import, display reason and continue to next STIG.
                        Write-Log -Path $STIGLog -Message "ERROR: $($ModError)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    Else {
                        # Set filename and additional requirements
                        ForEach ($SubJob in $Job.SubJobs) {
                            # Build ESData Object
                            If ($Job.STIGData.ShortName -match "^M_") {
                                $IsManualSTIG = $true
                            }
                            Else {
                                $IsManualSTIG = $false
                            }

                            $ESData = [Ordered]@{
                                ESVersion     = $ESVersion
                                StartTime     = (Get-Date -Format 'o')
                                ModuleName    = $PsModule.Name
                                ModuleVersion = $PsModule.Version
                                STIGName      = $Job.STIGData.Name
                                STIGShortName = $Job.STIGData.ShortName
                                CanCombine    = $Job.STIGData.CanCombine
                                STIGXMLName   = $($Job.STIGData.StigXmlPath | Split-Path -Leaf)
                                IsManualSTIG  = $IsManualSTIG
                                BaseFileName  = ""
                                AnswerFile    = $($SubJob.ScanArgs.ModuleArgs.AnswerFile -replace "'", "")
                                FileName      = @()
                            }

                            # Update BaseFileName if -SelectVuln is used
                            If ($SelectVuln) {
                                $SubJob.BaseFileName = "Partial_$($SubJob.BaseFileName)"
                            }

                            $ESData.BaseFileName = $($SubJob.BaseFileName)

                            # Write Site/Intance info to log
                            If ($SubJob.TargetData.Site) {
                                Write-Log -Path $STIGLog -Message "Site: $($SubJob.TargetData.Site)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            }
                            If ($SubJob.TargetData.Instance) {
                                Write-Log -Path $STIGLog -Message "Instance: $($SubJob.TargetData.Instance)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            }

                            # Write available Answer File variables
                            Write-Log -Path $STIGLog -Message "Answer File variables and values passed to module:" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            ForEach ($Key in $SubJob.ScanArgs.ModuleArgs.AnswerFileVars.Keys) {
                                If ($SubJob.ScanArgs.ModuleArgs.AnswerFileVars.$Key) {
                                    $Message = "  Variable: $" + $Key + "  |  Value: $($SubJob.ScanArgs.ModuleArgs.AnswerFileVars.$Key)"
                                    Write-Log -Path $STIGLog -Message $Message -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                }
                            }

                            # Execute scan
                            $ScanArgs = $SubJob.ScanArgs
                            $VulnResults = Invoke-STIGScan @ScanArgs

                            # Look for any failed checks
                            If ($VulnResults | Where-Object CheckError -EQ $true) {
                                $FailedCheck = $true
                                Write-Log -Path $STIGLog -Message "Scan completed with errors" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }
                            Else {
                                Write-Log -Path $STIGLog -Message "Scan complete" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            }

                            # Calculate Score and add to STIGInfo : (NF + NA) / Total Checks * 100
                            $EvalScore = [System.Math]::Round((($VulnResults | Where-Object Status -in @("NotAFinding", "Not_Applicable") | Measure-Object).Count / ($VulnResults | Measure-Object).Count * 100), 2)
                            $SubJob.STIGInfo.EvalScore = $EvalScore
                            Write-Log -Path $STIGLog -Message "EvalScore: $($EvalScore)%" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                            $SubJob.STIGInfo.CATI_OpenNRTotal = (($VulnResults | where-Object {$_.Status -in ("Not_Reviewed", "Open") -and $_.Severity -eq "High"}) | Measure-Object).count
                            $SubJob.STIGInfo.CATII_OpenNRTotal = (($VulnResults | where-Object {$_.Status -in ("Not_Reviewed", "Open") -and $_.Severity -eq "Medium"}) | Measure-Object).count
                            $SubJob.STIGInfo.CATIII_OpenNRTotal = (($VulnResults | where-Object {$_.Status -in ("Not_Reviewed", "Open") -and $_.Severity -eq "Low"}) | Measure-Object).count

                            Write-Log -Path $STIGLog -Message "CATI Open/NR: $($SubJob.STIGInfo.CATI_OpenNRTotal)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            Write-Log -Path $STIGLog -Message "CATII Open/NR: $($SubJob.STIGInfo.CATII_OpenNRTotal)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            Write-Log -Path $STIGLog -Message "CATIII Open/NR: $($SubJob.STIGInfo.CATIII_OpenNRTotal)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                            # Build ScanObject
                            $ScanObject = [System.Collections.Generic.List[System.Object]]::new()
                            $NewObj = [PSCustomObject]@{
                                ESData      = $ESData
                                STIGInfo    = $SubJob.STIGInfo
                                TargetData  = $SubJob.TargetData
                                VulnResults = $VulnResults
                            }
                            $ScanObject.Add($NewObj)

                            # Send ScanObject to outputs (CKL, CKLB, CSV, XCCDF)
                            If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)") {
                                Write-Progress -Id ($ProgressId + 1) -ParentId $ProgressId -Activity "Generating checklists..."
                                $tmpChecklistPath = Join-Path -Path $tmpResultsPath -ChildPath "Checklist"
                                If (-Not(Test-Path $tmpChecklistPath)) {
                                    $null = New-Item -Path $tmpChecklistPath -ItemType Directory
                                }
                                $GenerateSingleCKL = $false
                                $GenerateSingleCKLB = $false
                                $GenerateSingleCSV = $false
                                If ("CKL" -in $Output) {
                                    $GenerateSingleCKL = $true
                                }
                                If ("CombinedCKL" -in $Output) {
                                    If ($ScanObject.ESData.CanCombine -ne $true) {
                                        $GenerateSingleCKL = $true
                                    }
                                }
                                If ("CKLB" -in $Output) {
                                    $GenerateSingleCKLB = $true
                                }
                                If ("CombinedCKLB" -in $Output) {
                                    If ($ScanObject.ESData.CanCombine -ne $true) {
                                        $GenerateSingleCKLB = $true
                                    }
                                }
                                If ("CSV" -in $Output) {
                                    $GenerateSingleCSV = $true
                                }
                                If ("XCCDF" -in $Output) {
                                    $GenerateSingleXCCDF = $true
                                }

                                If ($GenerateSingleCKL) {
                                    Write-Log -Path $STIGLog -Message "Creating CKL file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                                    $ChecklistValid = Format-CKL -SchemaPath $Checklist_xsd -ScanObject $ScanObject -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent

                                    # Action for validation result
                                    If ($ChecklistValid) {
                                        $ScanObject.ESData.FileName += $(Split-Path $SaveFile -Leaf)
                                    }
                                }

                                If ($GenerateSingleCKLB) {
                                    Write-Log -Path $STIGLog -Message "Creating CKLB file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                                    $ChecklistValid = Format-CKLB -SchemaPath $Checklist_json -ScanObject $ScanObject -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent

                                    # Action for validation result
                                    If ($ChecklistValid) {
                                        $ScanObject.ESData.FileName += $(Split-Path $SaveFile -Leaf)
                                    }
                                }

                                if ($GenerateSingleCSV) {
                                    Write-Log -Path $STIGLog -Message "Creating CSV file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).csv")
                                    Format-Object -ScanObject $ScanObject -OutputPayload $OutputPayload | Export-Csv -NoTypeInformation -Path $SaveFile
                                    $ScanObject.ESData.FileName += $(Split-Path $SaveFile -Leaf)
                                }

                                If ($GenerateSingleXCCDF) {
                                    Write-Log -Path $STIGLog -Message "Creating XCCDF file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).xccdf.xml")
                                    $XCCDF = Format-XCCDF -ScanObject $ScanObject -OutputPath $SaveFile -Marking $Marking -ESPath $PSScriptRoot

                                    # Action for validation result
                                    If ($XCCDF -eq $true) {
                                        $ScanObject.ESData.FileName += $(Split-Path $SaveFile -Leaf)
                                    }
                                    Else {
                                        $ErrorData = $XCCDF | Get-ErrorInformation
                                        ForEach ($Prop in ($ErrorData.PSObject.Properties).Name) {
                                            Write-Log -Path $STIGLog -Message "$($Prop) : $($ErrorData.$Prop)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        }
                                    }
                                }

                                Write-Progress -Id ($ProgressId + 1) -ParentId $ProgressId -Activity "Generating checklists..." -Completed
                            }
                            # Add to ScanObjects object console or combined checklist output
                            $ScanObjects.Add($ScanObject)
                        }

                        If ($Job.STIGData.PsModule -ne "Manual"){
                            Write-Log -Path $STIGLog -Message "Removing scan module from memory" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            Remove-Module $Job.STIGData.PsModule -Force -ErrorAction SilentlyContinue
                        }
                        [System.GC]::Collect()
                        Start-Sleep -Seconds 1
                    }
                }
                Catch {
                    $ErrorData = $_ | Get-ErrorInformation
                    If ($STIGLog -and (Test-Path $STIGLog)) {
                        ForEach ($Prop in ($ErrorData.PSObject.Properties).Name) {
                            Write-Log -Path $STIGLog -Message "$($Prop) : $($ErrorData.$Prop)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                    Write-Log -Path $STIGLog -Message "Continuing Processing" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    [System.GC]::Collect()
                    Start-Sleep -Seconds 1
                }
            }

            # Create combined checklists
            If (($Output -split ",").Trim() -match "(^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)") {
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating combined checklists" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                If (($Output -split ",").Trim() -match "(^CombinedCKL$)") {
                    Write-Log -Path $STIGLog -Message "Creating combined CKL file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                    }
                    $null = Format-CKL -SchemaPath $Checklist_xsd -ScanObject $ScanObjects -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent
                }
                If (($Output -split ",").Trim() -match "(^CombinedCKLB$)") {
                    Write-Log -Path $STIGLog -Message "Creating combined CKLB file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                    }
                    $null = Format-CKLB -SchemaPath $Checklist_json -ScanObject $ScanObjects -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent
                }
                If (($Output -split ",").Trim() -match "(^CombinedCSV$)") {
                    Write-Log -Path $STIGLog -Message "Creating combined CSV file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).csv")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).csv")
                    }

                    Format-Object -ScanObject $ScanObjects -OutputPayload $OutputPayload | Export-Csv -NoTypeInformation -Path $SaveFile
                }
            }

            If ($FailedCheck -eq $true) {
                Write-Log -Path $STIGLog -Message "Please report issues to https://spork.navsea.navy.mil/nswc-crane-division/evaluate-stig/-/issues" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
            }

            # Send results to STIG Manager
            If (($Output -split ",").Trim() -match "(^STIGManager$)") {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Importing to STIG Manager" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++

                Try {
                    if ($SMPassphrase) {
                        $SMImport_Params = Get-SMParameters -SMCollection $SMCollection -SMPassphrase $SMPassphrase -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog
                    }
                    else {
                        $SMImport_Params = Get-SMParameters -SMCollection $SMCollection -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog
                    }

                    Import-Asset @SMImport_Params
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            # Send results to Splunk
            If (($Output -split ",").Trim() -match "(^Splunk$)") {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Importing to Splunk" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                Try {
                    $Splunk_Params = Get-SplunkParameters -SplunkHECName $SplunkHECName -OutputPayload $OutputPayload -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog

                    Import-Event @Splunk_Params
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            # Create OQE
            If (($Output -split ",").Trim() -match "(^OQE$)") {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Switch ($OSPlatform) {
                    "Windows" {
                        Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating Objective Quality Evidence (OQE) output" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                        $CurrentMainStep++
                        Write-Log -Path $STIGLog -Message "Generating Objective Quality Evidence (OQE) output" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Try {
                            $tmpOQEPath = $(Join-Path -Path $tmpResultsPath -ChildPath "OQE")
                            If (-Not(Test-Path $tmpOQEPath)) {
                                $null = New-Item -Path $tmpOQEPath -ItemType Directory
                            }

                            # Group Policy Report
                            Try {
                                Write-Log -Path $STIGLog -Message "Pulling Group Policy Report" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                $GPResultFile = "GPResult_$(${env:computername})_$($Date).html"
                                If ($UserToProcess -and $UserToProcess.SID -notin @("NA", ".DEFAULT")) {
                                    Start-Process -FilePath GPResult.exe -ArgumentList "/USER $($UserToProcess.Username) /H $tmpOQEPath\$($GPResultFile)" -Wait -WindowStyle Hidden
                                }
                                Else {
                                    Write-Log -Path $STIGLog -Message "    No profile selected as user to evaluate.  Group Policy results will not include user policies." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                                    Start-Process -FilePath GPResult.exe -ArgumentList "/SCOPE COMPUTER /H $tmpOQEPath\$($GPResultFile)" -Wait -WindowStyle Hidden
                                }
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }

                            # AppLocker Report
                            Try {
                                Write-Log -Path $STIGLog -Message "Collecting AppLocker effective policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                $AppLockerPolFile = "AppLockerPol_$(${env:computername})_$($Date).xml"
                                If (($PsVersionTable.PSVersion -join ".") -lt [Version]"7.0") {
                                    Import-Module AppLocker
                                }
                                Else {
                                    Import-Module AppLocker -SkipEditionCheck
                                }
                                Get-AppLockerPolicy -Effective -Xml -ErrorAction Stop | Out-File $tmpOQEPath\$($AppLockerPolFile) -Force -Encoding UTF8
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }

                            # Security Policy
                            Try {
                                $SecPolFile = "SecPol_$(${env:computername})_$($Date).ini"
                                Write-Log -Path $STIGLog -Message "Exporting security policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                Start-Process -FilePath secedit.exe -ArgumentList "/export /cfg $($tmpOQEPath)\$($SecPolFile)" -Wait -WindowStyle Hidden
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                    "Linux" {
                        $CurrentMainStep++
                        # Placeholder in the event there is something we want to provide as OQE for Linux systems.
                    }
                }
            }

            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Get RiskScore
            Write-Log -Path $STIGLog -Message "Calculating risk score..." -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            $RiskScoreObject = Get-RiskScore -ES_Path $PsScriptRoot -ApplicableSTIGsCount $ApplicableSTIGsCount -ScanObjects $ScanObjects
            $ScoreDataObject = [ordered]@{}
            ForEach ($Key in $RiskScoreObject.Keys) {
                Switch ($Key) {
                    "CountRetrievalSuccess" {
                        If ($RiskScoreObject.$Key -ne 1) {
                            Write-Log -Path $STIGLog -Message "Failed to get full CAT counts for grading.  Scoring will be inaccurate." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                    "WeightedAvg" {
                        Write-Log -Path $STIGLog -Message "$($Key): $($RiskScoreObject.$Key)%" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                    DEFAULT {
                        Write-Log -Path $STIGLog -Message "$($Key): $($RiskScoreObject.$Key)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                }
                $ScoreDataObject.Add($Key, $RiskScoreObject.$Key)
            }
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Determine FullScan
            $FullScan = $true
            If ($SelectVuln -or $ExcludeVuln) {
                # SelectVuln|ExcludeVuln automatically disqualifies as a full scan
                $FullScan = $false
            }
            ForEach ($STIG in $ApplicableSTIGs.ShortName) {
                If (-Not($ProcessedSTIGs.ShortName -match $STIG)) {
                    # Applicable STIG was not processed.  Not a full scan
                    $FullScan = $false
                }
            }

            # Build ScanSummary object and add to AssetData
            $ScanSummaryObject = [ordered]@{
                ApplicableSTIGs    = $ApplicableSTIGsCount | Sort-Object ShortName
                ProcessedSTIGs     = $ProcessedSTIGs | Sort-Object Shortname
                FullScan           = $FullScan
                Score              = $ScoreDataObject
            }
            $AssetData.Add("ScanSummary", $ScanSummaryObject)

            If (($Output -split ",").Trim() -match "(^Summary$)") {
                # Create summary report
                Write-Log -Path $STIGLog -Message "Generating summary report" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating summary report" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                if ($Marking) {
                    Write-SummaryReport -AssetData $AssetData -RiskScoreObject $RiskScoreObject -ScanResult $ScanObjects -OutputPath $tmpResultsPath -ProcessedUser $UserToProcess.Username -Detail -Platform $OSPlatform -ScanStartDate $ScanStartDate -ScanType $ScanType -Marking $Marking
                }
                else {
                    Write-SummaryReport -AssetData $AssetData -RiskScoreObject $RiskScoreObject -ScanResult $ScanObjects -OutputPath $tmpResultsPath -ProcessedUser $UserToProcess.Username -Detail -Platform $OSPlatform -ScanStartDate $ScanStartDate -ScanType $ScanType
                }

                # Create Summary HTML
                $SummaryFile = Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.xml
                [xml]$TempSR = New-Object xml

                $null = $TempSR.AppendChild($TempSR.CreateElement('Summaries'))
                $summary = New-Object xml
                $Summary.Load($SummaryFile)
                $ImportedSummary = $TempSR.ImportNode($Summary.DocumentElement, $true)
                $null = $TempSR.DocumentElement.AppendChild($ImportedSummary)

                $TempSR.Summaries.Summary.Results.Result | ForEach-Object {
                    #Build STIG name
                    $STIGName = [String]"$($_.STIG -replace '_', ' ') V$($_.Version)R$($_.Release)"
                    If ($_.Site) {
                        $STIGName = $STIGName + " ($($_.Site))"
                    }
                    If ($_.Instance) {
                        $STIGName = $STIGName + " ($($_.Instance))"
                    }
                    $_.SetAttribute("STIG", $STIGName)
                    $_.SetAttribute("StartTime", [String]($_.StartTime -replace "\.\d+", ""))
                    $CurrentScoreNode = $_.AppendChild($TempSR.CreateElement('CurrentScore'))
                    $CurrentScore = ([int]$_.CAT_I.NotAFinding + [int]$_.CAT_II.NotAFinding + [int]$_.CAT_III.NotAFinding + [int]$_.CAT_I.Not_Applicable + [int]$_.CAT_II.Not_Applicable + [int]$_.CAT_III.Not_Applicable) / ([int]$_.CAT_I.Total + [int]$_.CAT_II.Total + [int]$_.CAT_III.Total)
                    $CurrentScoreNode.SetAttribute("Score", $CurrentScore)
                }
                $TempSR.Save($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml))

                $SummaryReportXLST = New-Object System.XML.Xsl.XslCompiledTransform
                $SummaryReportXLST.Load($(Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath SummaryReport.xslt))
                $SummaryReportXLST.Transform($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml), $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html))

                if ($Marking) {
                    #Add Marking Header and Footer
                    $SRHTML = $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html)
                    (Get-Content $SRHTML) -replace "<body>", "<body>`n    <header align=`"center`">$Marking</header>" | Set-Content $SRHTML

                    Add-Content $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html) "<footer align=`"center`">$Marking</footer>"
                }
            }

            # Manage previous results and move results to ResultsPath
            If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)") {
                If ($SelectSTIG) {
                    $PreviousArgs = @{SelectedShortName = $STIGsToProcess.ShortName}
                    If (($Output -split ",").Trim() -match "(^CombinedCKL$)") {
                        $PreviousArgs.Add("SelectedCombinedCKL", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^CombinedCKLB$)") {
                        $PreviousArgs.Add("SelectedCombinedCKLB", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^CombinedCSV$)") {
                        $PreviousArgs.Add("SelectedCombinedCSV", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^Summary$)") {
                        $PreviousArgs.Add("SelectedSummary", $true)
                    }
                    If (($Output -split ",").Trim() -match "(^OQE$)") {
                        $PreviousArgs.Add("SelectedOQE", $true)
                    }
                    Initialize-PreviousProcessing -ResultsPath $ResultsPath -PreviousToKeep $PreviousToKeep @PreviousArgs -LogPath $STIGLog -LogComponent $LogComponent -OSPlatform $OSPlatform
                }
                Else {
                    Initialize-PreviousProcessing -ResultsPath $ResultsPath -PreviousToKeep $PreviousToKeep -LogPath $STIGLog -LogComponent $LogComponent -OSPlatform $OSPlatform
                }

                # Move results to ResultsPath
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Log -Path $STIGLog -Message "Copying output files to $ResultsPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                If (-Not(Test-Path $ResultsPath)) {
                    # Create $ResultsPath
                    $null = New-Item -Path $ResultsPath -ItemType Directory
                }
                Get-ChildItem $tmpResultsPath -Recurse | ForEach-Object {
                    If ($_.PSIsContainer) {
                        If (-Not(Test-Path $(Join-Path $ResultsPath -ChildPath $_.Name))) {
                            $null = New-Item -Path $(Join-Path $ResultsPath -ChildPath $_.Name) -ItemType Directory
                        }
                    }
                    Else {
                        Copy-Item -Path $_.FullName -Destination $(Join-Path -Path $ResultsPath -ChildPath $(($_.DirectoryName) -ireplace [regex]::Escape($tmpResultsPath), ""))
                    }
                }
            }

            # Apply tattoo
            If ($ApplyTattoo) {
                Write-Log -Path $STIGLog -Message "Applying Evaluate-STIG tattoo" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Tattoo -AssetData $AssetData -LastCommand $CommandLine -ScanObjects $ScanObjects -OSPlatform $OSPlatform -STIGLog $STIGLog
            }

            # Clean up
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
            Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent

            # Finalize log and get totals
            $TimeToComplete = New-TimeSpan -Start $StartTime -End (Get-Date)
            $FormatedTime = "{0:c}" -f $TimeToComplete
            Write-Log -Path $STIGLog -Message "Done!" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Total Time : $($FormatedTime)" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)") {
                $TotalChecklists = (Get-ChildItem -Path "$ResultsPath\Checklist" | Where-Object {($_.Extension -In @(".ckl", ".cklb", ".csv") -or $_.Name -like "*.xccdf.xml")}  | Measure-Object).Count
                Write-Log -Path $STIGLog -Message "Total checklists in Results Directory : $($TotalChecklists)" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Host ""
                Write-Host "Results saved to " -ForegroundColor Green -NoNewline; Write-Host "$($ResultsPath)" -ForegroundColor Cyan
            }
            Write-Log -Path $STIGLog -Message "Exiting with exit code $ExitCode" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If ($Marking) {
                Write-Log -Path $STIGLog -Message "                                                                                          $Marking                                                                                          " -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            Write-Host ""

            # Copy Evaluate-STIG.log to results path
            If (($Output -split ",").Trim() -match "(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)") {
                Copy-Item $STIGLog -Destination $ResultsPath -Force -ErrorAction Stop
            }

            # Complete progress bar
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed
            If (($Output -split ",").Trim() -match "(^Console$)") {
                # Configure a default display set
                $defaultDisplaySet = 'STIGInfo', 'TargetData', 'VulnResults'

                # Create the default property display set
                $defaultDisplayPropertySet = New-Object System.Management.Automation.PSPropertySet('DefaultDisplayPropertySet', [string[]]$defaultDisplaySet)
                $PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]@($defaultDisplayPropertySet)

                # Build ScanResult
                $ScanResult = @{}
                $ScanResult.Add($MachineName, $ScanObjects)
            }
        }
        #endregion Local Scan

        # Remove InstalledSoftware variable if it exists
        If ($null -ne $Global:InstalledSoftware) {
            Remove-Variable -Name InstalledSoftware -Scope Global
        }

        If (($Output -split ",").Trim() -match "(^Console$)") {
            If (($ScanResult.Keys | Measure-Object).Count -ge 1) {
                # Configure a default display set
                $defaultDisplaySet = 'STIGInfo', 'TargetData', 'VulnResults'

                # Create the default property display set
                $defaultDisplayPropertySet = New-Object System.Management.Automation.PSPropertySet('DefaultDisplayPropertySet', [string[]]$defaultDisplaySet)
                $PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]@($defaultDisplayPropertySet)

                # Format, sort, and return output
                $ScanOutput = [ordered]@{}
                If ($ComputerName) {
                    ForEach ($HostName in ($ScanResult.Keys | Sort-Object)) {
                        $HostOutput = [ordered]@{}
                        ForEach ($Target in ($ScanResult.$HostName.Keys | Sort-Object -Property @{Expression = {If ($_ -eq "AssetData") {0} Else {$_}}})) {
                            If ($Target -eq "AssetData") {
                                $HostOutput.Add($($Target), $ScanResult.$HostName.$Target)
                            }
                            Else {
                                $OutObject = $ScanResult.$HostName.$Target | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                                $OutObject.PSObject.TypeNames.Insert(0, 'ScanResult')
                                $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers
                                $HostOutput.Add($($Target), $OutObject)
                            }
                        }
                        $ScanOutput.Add($HostName, $HostOutput)
                    }
                }
                Else {
                    $tmpOutput = @{}
                    ForEach ($Target in $ScanResult.Keys | Sort-Object) {
                        If ($CiscoConfig) {
                            If (($ScanResult[$Target].AssetData | Group-Object).Count -gt 1) {
                                $AssetData = $ScanResult[$Target].AssetData[0]
                            }
                            Else {
                                $AssetData = $ScanResult[$Target].AssetData
                            }
                        }

                        $HostOutput = [ordered]@{
                            AssetData = $AssetData
                        }
                        $STIGCount = @{}
                        # Handle if STIG has more than a count of 1
                        $ScanResult[$Target].ESData.STIGShortName | Sort-Object -Unique | ForEach-Object {
                            $STIGCount | Add-Member -MemberType NoteProperty -Name $_ -Value 1
                        }
                        If (($ScanResult.$Target.ESData.STIGShortName | Measure-Object).Count -gt 1) {
                            $GroupedObj = $ScanResult.$Target.ESData.STIGShortName.GetEnumerator() | Group-Object
                        }
                        Else {
                            $GroupedObj = $ScanResult.$Target.ESData.STIGShortName | Group-Object
                        }

                        Foreach ($Object in $ScanResult[$Target]) {
                            $OutObject = $Object | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                            $OutObject.PSObject.TypeNames.Insert(0, 'ScanResult')
                            $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers

                            $STIGShortName = $Object.ESData.STIGShortName
                            if (($GroupedObj | Where-Object {$_.Name -like $STIGShortName}).Count -gt 1) {
                                $STIGCount[$STIGShortName]++
                                $HostOutput.Add("$STIGShortName$($STIGCount[$STIGShortName])", $OutObject)
                            }
                            Else {
                                $HostOutput.Add($($STIGShortName), $OutObject)
                            }
                        }
                        $tmpOutput.Add($Target, $HostOutput)
                    }


                    # Put into new object to ensure sorting
                    $HostNames = $tmpOutput.GetEnumerator().Name | Sort-Object
                    ForEach ($HostName in $HostNames) {
                        $OrderedResults = [ordered]@{}
                        ForEach ($Target in ($tmpOutput.$HostName.Keys | Sort-Object -Property @{Expression = {If ($_ -eq "AssetData") {0} Else {$_}}})) {
                            If ($Target -eq "AssetData") {
                                $OrderedResults.Add($($Target), $tmpOutput.$HostName.$Target)
                            }
                            Else {
                                $OutObject = $tmpOutput.$HostName.$Target | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                                $OutObject.PSObject.TypeNames.Insert(0, 'ScanResult')
                                $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers
                                $OrderedResults.Add($($Target), $OutObject)
                            }
                        }
                        $ScanOutput.Add($HostName, $OrderedResults)
                    }
                }

                if ($JSON) {
                    $HostOutput = [System.Collections.Generic.List[System.Object]]::new()
                    ForEach ($HostName in ($ScanOutput.Keys | Sort-Object)) {
                        ForEach ($Target in ($ScanOutput.$HostName.Keys | Sort-Object)) {
                            $OutObject = $ScanOutput.$HostName.$Target | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                            $OutObject.PSObject.TypeNames.Insert(0, 'ScanOutput')
                            $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers
                            $HostOutput.Add($OutObject)
                        }
                    }

                    $JSONResult = Format-Object -ScanObject $HostOutput -OutputPayload $OutputPayload | ConvertTo-Json
                }
            }

            If ($PSStyleBackup) {
                # Restore $PSStyle settings
                $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()
            Start-Sleep -Seconds 1

            If ($JSONResult) {
                Return $JSONResult
            }
            ElseIf ($ScanOutput) {
                Return $ScanOutput
            }
        }
        Else {
            If ($PSStyleBackup) {
                # Restore $PSStyle settings
                $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
            }

            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()
            Start-Sleep -Seconds 1

            Exit $ExitCode
        }
    }
    Catch {
        If ($ExitCode -eq 0) {
            $ExitCode = 1
        }

        $MasterFunctionsLoaded = $false
        If (Get-Module -Name Master_Functions) {
            $MasterFunctionsLoaded = $true
        }

        # Get Error Data
        If ($MasterFunctionsLoaded) {
            $ErrorData = $_ | Get-ErrorInformation
            If ($STIGLog -and (Test-Path $STIGLog)) {
                ForEach ($Prop in ($ErrorData.PSObject.Properties).Name) {
                    Write-Log -Path $STIGLog -Message "$($Prop) : $($ErrorData.$Prop)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }
        }
        Else {
            $ErrorData = [PSCustomObject]@{
                ExceptionMessage = $_.Exception.Message
            }
        }

        # --- Begin : Clean up ---
        # Update progress bar
        If ($ProgressId) {
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "ERROR DETECTED : Cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
        }

        # Initiate post scan cleanup
        If ($WorkingDir -and (Test-Path $WorkingDir) -and $MasterFunctionsLoaded) {
            Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent
        }

        # Remove $InstalledSoftware variable from memory
        If ($null -ne $Global:InstalledSoftware) {
            Remove-Variable -Name InstalledSoftware -Scope Global
        }

        # Remove $AvailableModules variable from memory
        If ($null -ne $AvailableModules) {
            Remove-Variable -Name 'AvailableModules'
        }

        # Remove remote scan lock file from disk
        If ($ComputerName) {
            If (Test-Path $RemoteWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $RemoteWorkingDir\Evaluate-STIG.lck -Force -ErrorAction SilentlyContinue
            }
        }

        # Remove Cisco lock file from disk
        If ($CiscoConfig) {
            If (Test-Path $CiscoWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $CiscoWorkingDir\Evaluate-STIG.lck -Force -ErrorAction SilentlyContinue
            }
        }

        # Remove VCenter lock file from disk
        If ($VCenterApplianceName -or $VMName) {
            If (Test-Path $VCenterWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $VCenterWorkingDir\Evaluate-STIG.lck -Force -ErrorAction SilentlyContinue
            }
        }

        # Write final log entry
        If ($STIGLog -and (Test-Path $STIGLog) -and $MasterFunctionsLoaded) {
            Write-Log -Path $STIGLog -Message "Exiting with exit code $ExitCode" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
        }

        # Remove Evaluate-STIG modules from memory
        Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
        [System.GC]::Collect()
        Start-Sleep -Seconds 1

        # Complete progress bar
        If ($ProgressId) {
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "ERROR DETECTED : Cleaning up" -Completed
        }


        If ($PSStyleBackup) {
            # Restore $PSStyle settings
            $PSStyle.Progress.View = $PSStyleBackup.ProgressView
            $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
        }
        # --- Begin : Clean up ---
        # Write the error to console and exit with $ExitCode
        $PropsForOutput = @("Message", "ScriptName", "Line", "Column")
        $MaxLength = (($ErrorData | Get-Member | Where-Object {$_.Name -in $PropsForOutput -and $_.MemberType -in @('Property', 'NoteProperty')}).Name | Measure-Object -Maximum -Property Length).Maximum + 1
        foreach ($Item in $PropsForOutput) {
            $WhiteSpace = ' ' * ($MaxLength - $Item.Length)
            Write-Host "$($Item)$($WhiteSpace): $($ErrorData.$Item)" -ForegroundColor Red -BackgroundColor Black
        }

        Exit $ExitCode
    }
}

# SIG # Begin signature block
# MIIkCwYJKoZIhvcNAQcCoIIj/DCCI/gCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCAalMjDMa6BhzGx
# SlOUNYcmFpJ/T/BihAjfPgBn5t0OoqCCHiQwggUqMIIEEqADAgECAgMTYdUwDQYJ
# KoZIhvcNAQELBQAwWjELMAkGA1UEBhMCVVMxGDAWBgNVBAoTD1UuUy4gR292ZXJu
# bWVudDEMMAoGA1UECxMDRG9EMQwwCgYDVQQLEwNQS0kxFTATBgNVBAMTDERPRCBJ
# RCBDQS03MjAeFw0yNTAzMjUwMDAwMDBaFw0yODAzMjMyMzU5NTlaMIGOMQswCQYD
# VQQGEwJVUzEYMBYGA1UEChMPVS5TLiBHb3Zlcm5tZW50MQwwCgYDVQQLEwNEb0Qx
# DDAKBgNVBAsTA1BLSTEMMAoGA1UECxMDVVNOMTswOQYDVQQDEzJDUy5OQVZBTCBT
# VVJGQUNFIFdBUkZBUkUgQ0VOVEVSIENSQU5FIERJVklTSU9OLjAwMTCCASIwDQYJ
# KoZIhvcNAQEBBQADggEPADCCAQoCggEBALl8XR1aeL1ARA9c9RE46+zVmtnbYcsc
# D6WG/eVPobPKhzYePfW3HZS2FxQQ0yHXRPH6AS/+tjCqpGtpr+MA5J+r5X9XkqYb
# 1+nwfMlXHCQZDLAsmRN4bNDLAtADzEOp9YojDTTIE61H58sRSw6f4uJwmicVkYXq
# Z0xrPO2xC1/B0D7hzBVKmxeVEcWF81rB3Qf9rKOwiWz9icMZ1FkYZAynaScN5UIv
# V+PuLgH0m9ilY54JY4PWEnNByxM/2A34IV5xG3Avk5WiGFMGm1lKCx0BwsKn0PfX
# Kd0RIcu/fkOEcCz7Lm7NfsQQqtaTKRuBAE5mLiD9cmmbt2WcnfAQvPcCAwEAAaOC
# AcIwggG+MB8GA1UdIwQYMBaAFIP0XzXrzNpde5lPwlNEGEBave9ZMDcGA1UdHwQw
# MC4wLKAqoCiGJmh0dHA6Ly9jcmwuZGlzYS5taWwvY3JsL0RPRElEQ0FfNzIuY3Js
# MA4GA1UdDwEB/wQEAwIGwDAWBgNVHSAEDzANMAsGCWCGSAFlAgELKjAdBgNVHQ4E
# FgQUmWLtMKC6vsuXOz9nYQtTtn1sApcwZQYIKwYBBQUHAQEEWTBXMDMGCCsGAQUF
# BzAChidodHRwOi8vY3JsLmRpc2EubWlsL3NpZ24vRE9ESURDQV83Mi5jZXIwIAYI
# KwYBBQUHMAGGFGh0dHA6Ly9vY3NwLmRpc2EubWlsMIGSBgNVHREEgYowgYekgYQw
# gYExCzAJBgNVBAYTAlVTMRgwFgYDVQQKEw9VLlMuIEdvdmVybm1lbnQxDDAKBgNV
# BAsTA0RvRDEMMAoGA1UECxMDUEtJMQwwCgYDVQQLEwNVU04xLjAsBgNVBAMTJUlS
# RUxBTkQuREFOSUVMLkNIUklTVE9QSEVSLjEzODcxNTAzMzgwHwYDVR0lBBgwFgYK
# KwYBBAGCNwoDDQYIKwYBBQUHAwMwDQYJKoZIhvcNAQELBQADggEBAI7+Xt5NkiSp
# YYEaISRpmsKDnEpuoKzvHjEKl41gmTMLnj7mVTLQFm0IULnaLu8FHelUkI+RmFFW
# gHwaGTujbe0H9S6ySzKQGGSt7jrZijYGAWCG/BtRUVgOSLlWZsLxiVCU07femEGT
# 2JQTEhx5/6ADAE/ZT6FZieiDYa7CZ14+1yKZ07x+t5k+hKAHEqdI6+gkInxqwunZ
# 8VFUoPyTJDsiifDXj5LG7+vUr6YNWZfVh2QJJeQ3kmheKLXRIqNAX2Ova3gFUzme
# 05Wp9gAT4vM7Zk86cHAqVFtwOnK/IGRKBWyEW1btJGWM4yk98TxGKh5JSPN4EAln
# 3i2bAfl2BLAwggWNMIIEdaADAgECAhAOmxiO+dAt5+/bUOIIQBhaMA0GCSqGSIb3
# DQEBDAUAMGUxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAX
# BgNVBAsTEHd3dy5kaWdpY2VydC5jb20xJDAiBgNVBAMTG0RpZ2lDZXJ0IEFzc3Vy
# ZWQgSUQgUm9vdCBDQTAeFw0yMjA4MDEwMDAwMDBaFw0zMTExMDkyMzU5NTlaMGIx
# CzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3
# dy5kaWdpY2VydC5jb20xITAfBgNVBAMTGERpZ2lDZXJ0IFRydXN0ZWQgUm9vdCBH
# NDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAL/mkHNo3rvkXUo8MCIw
# aTPswqclLskhPfKK2FnC4SmnPVirdprNrnsbhA3EMB/zG6Q4FutWxpdtHauyefLK
# EdLkX9YFPFIPUh/GnhWlfr6fqVcWWVVyr2iTcMKyunWZanMylNEQRBAu34LzB4Tm
# dDttceItDBvuINXJIB1jKS3O7F5OyJP4IWGbNOsFxl7sWxq868nPzaw0QF+xembu
# d8hIqGZXV59UWI4MK7dPpzDZVu7Ke13jrclPXuU15zHL2pNe3I6PgNq2kZhAkHnD
# eMe2scS1ahg4AxCN2NQ3pC4FfYj1gj4QkXCrVYJBMtfbBHMqbpEBfCFM1LyuGwN1
# XXhm2ToxRJozQL8I11pJpMLmqaBn3aQnvKFPObURWBf3JFxGj2T3wWmIdph2PVld
# QnaHiZdpekjw4KISG2aadMreSx7nDmOu5tTvkpI6nj3cAORFJYm2mkQZK37AlLTS
# YW3rM9nF30sEAMx9HJXDj/chsrIRt7t/8tWMcCxBYKqxYxhElRp2Yn72gLD76GSm
# M9GJB+G9t+ZDpBi4pncB4Q+UDCEdslQpJYls5Q5SUUd0viastkF13nqsX40/ybzT
# QRESW+UQUOsxxcpyFiIJ33xMdT9j7CFfxCBRa2+xq4aLT8LWRV+dIPyhHsXAj6Kx
# fgommfXkaS+YHS312amyHeUbAgMBAAGjggE6MIIBNjAPBgNVHRMBAf8EBTADAQH/
# MB0GA1UdDgQWBBTs1+OC0nFdZEzfLmc/57qYrhwPTzAfBgNVHSMEGDAWgBRF66Kv
# 9JLLgjEtUYunpyGd823IDzAOBgNVHQ8BAf8EBAMCAYYweQYIKwYBBQUHAQEEbTBr
# MCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5jb20wQwYIKwYBBQUH
# MAKGN2h0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEFzc3VyZWRJ
# RFJvb3RDQS5jcnQwRQYDVR0fBD4wPDA6oDigNoY0aHR0cDovL2NybDMuZGlnaWNl
# cnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENBLmNybDARBgNVHSAECjAIMAYG
# BFUdIAAwDQYJKoZIhvcNAQEMBQADggEBAHCgv0NcVec4X6CjdBs9thbX979XB72a
# rKGHLOyFXqkauyL4hxppVCLtpIh3bb0aFPQTSnovLbc47/T/gLn4offyct4kvFID
# yE7QKt76LVbP+fT3rDB6mouyXtTP0UNEm0Mh65ZyoUi0mcudT6cGAxN3J0TU53/o
# Wajwvy8LpunyNDzs9wPHh6jSTEAZNUZqaVSwuKFWjuyk1T3osdz9HNj0d1pcVIxv
# 76FQPfx2CWiEn2/K2yCNNWAcAgPLILCsWKAOQGPFmCLBsln1VWvPJ6tsds5vIy30
# fnFqI2si/xK4VC0nftg62fC2h5b9W9FcrBjDTZ9ztwGpn1eqXijiuZQwggW4MIID
# oKADAgECAgFIMA0GCSqGSIb3DQEBDAUAMFsxCzAJBgNVBAYTAlVTMRgwFgYDVQQK
# Ew9VLlMuIEdvdmVybm1lbnQxDDAKBgNVBAsTA0RvRDEMMAoGA1UECxMDUEtJMRYw
# FAYDVQQDEw1Eb0QgUm9vdCBDQSA2MB4XDTIzMDUxNjE2MDIyNloXDTI5MDUxNTE2
# MDIyNlowWjELMAkGA1UEBhMCVVMxGDAWBgNVBAoTD1UuUy4gR292ZXJubWVudDEM
# MAoGA1UECxMDRG9EMQwwCgYDVQQLEwNQS0kxFTATBgNVBAMTDERPRCBJRCBDQS03
# MjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALi+DvkbsJrZ8W6Dbflh
# Bv6ONtCSv5QQ+HAE/TlN3/9qITfxmlSWc9S702/NjzgTxJv36Jj5xD0+shC9k+5X
# IQNEZHeCU0C6STdJJwoJt2ulrK5bY919JGa3B+/ctujJ6ZAFMROBwo0b18uzeykH
# +bRhuvNGrpYMJljoMRsqcdWbls+I78qz3YZQQuq5f3LziE03wD5eFRsmXt9PrCaR
# FiftqjezlmoiMOdGbr/DFaLDHkrf/fvtQmreIPKQuQFwmw190LvhdUa4yjshnTV9
# nv1Wo22Yc8US2N3vEOwr5oQPLt/bQyhPHvPt6WNJMqjr7grwSrScJNb2Yr7Fz3I/
# 1fECAwEAAaOCAYYwggGCMB8GA1UdIwQYMBaAFBNPPLvbXUUppZRwttqsnkziL8EL
# MB0GA1UdDgQWBBSD9F8168zaXXuZT8JTRBhAWr3vWTAOBgNVHQ8BAf8EBAMCAYYw
# ZwYDVR0gBGAwXjALBglghkgBZQIBCyQwCwYJYIZIAWUCAQsnMAsGCWCGSAFlAgEL
# KjALBglghkgBZQIBCzswDAYKYIZIAWUDAgEDDTAMBgpghkgBZQMCAQMRMAwGCmCG
# SAFlAwIBAycwEgYDVR0TAQH/BAgwBgEB/wIBADAMBgNVHSQEBTADgAEAMDcGA1Ud
# HwQwMC4wLKAqoCiGJmh0dHA6Ly9jcmwuZGlzYS5taWwvY3JsL0RPRFJPT1RDQTYu
# Y3JsMGwGCCsGAQUFBwEBBGAwXjA6BggrBgEFBQcwAoYuaHR0cDovL2NybC5kaXNh
# Lm1pbC9pc3N1ZWR0by9ET0RST09UQ0E2X0lULnA3YzAgBggrBgEFBQcwAYYUaHR0
# cDovL29jc3AuZGlzYS5taWwwDQYJKoZIhvcNAQEMBQADggIBALAs2CLSvmi9+W/r
# cF0rh09yoqQphPSu6lKv5uyc/3pz3mFL+lFUeIdAVihDbP4XKB+wr+Yz34LeeL82
# 79u3MBAEk4xrJOH29uiRBJFTtMdt8GvOecd2pZSGFbDMTt10Bh9N+IvGYclwMkvt
# 26Q+VlZysQr3fQQ8QdO6z4e9jTFR92QmoW4eLyx8CmgZT2CESRl60Ey0A6Gf87Hh
# ntetRp9k0VkFOk7hWfCSUFBhTrmuJBgNB9HP7e5DuPwKUZLICziVxVrZydoyUmyX
# Aki9q6VrUAsm/1/i/YeUInqtXJZ2vs3foMsNa/tVSQ1BG1Wn/1ZfVzWLd+sAA/nk
# CnbsMc61UG8Yec0jC4WMCsmsQKLEfPrt9/U+tEuX9mqeD3dtpR+vq18av8FNd1mY
# zRgFdNc2+P09daj70PslCCb64XAJh1RY4zHPsOA9o+OXdHAX0kpTackvueXyuLb6
# BM0FCaTpq83Y2oH55kM/pPN3brNHUcIkBzqTj48X3WgQbrrwvGTWh4PSGoitnvsB
# nxsBfAFbqugOUEnnIk0an2Vdl3zGXBooAiODnd/n87Ht7psLp7koapfXTGJBClZU
# mSFpdwtI15hvdw9KThK41bC0cLu8lZ4TEFAxSJyuGjxkhBKXeq7LrRSjO8T+bHte
# u6ud36J9k9xg5brIqTW2ripCBEEtMIIGtDCCBJygAwIBAgIQDcesVwX/IZkuQEMi
# DDpJhjANBgkqhkiG9w0BAQsFADBiMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGln
# aUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSEwHwYDVQQDExhE
# aWdpQ2VydCBUcnVzdGVkIFJvb3QgRzQwHhcNMjUwNTA3MDAwMDAwWhcNMzgwMTE0
# MjM1OTU5WjBpMQswCQYDVQQGEwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4x
# QTA/BgNVBAMTOERpZ2lDZXJ0IFRydXN0ZWQgRzQgVGltZVN0YW1waW5nIFJTQTQw
# OTYgU0hBMjU2IDIwMjUgQ0ExMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKC
# AgEAtHgx0wqYQXK+PEbAHKx126NGaHS0URedTa2NDZS1mZaDLFTtQ2oRjzUXMmxC
# qvkbsDpz4aH+qbxeLho8I6jY3xL1IusLopuW2qftJYJaDNs1+JH7Z+QdSKWM06qc
# hUP+AbdJgMQB3h2DZ0Mal5kYp77jYMVQXSZH++0trj6Ao+xh/AS7sQRuQL37QXbD
# hAktVJMQbzIBHYJBYgzWIjk8eDrYhXDEpKk7RdoX0M980EpLtlrNyHw0Xm+nt5pn
# YJU3Gmq6bNMI1I7Gb5IBZK4ivbVCiZv7PNBYqHEpNVWC2ZQ8BbfnFRQVESYOszFI
# 2Wv82wnJRfN20VRS3hpLgIR4hjzL0hpoYGk81coWJ+KdPvMvaB0WkE/2qHxJ0ucS
# 638ZxqU14lDnki7CcoKCz6eum5A19WZQHkqUJfdkDjHkccpL6uoG8pbF0LJAQQZx
# st7VvwDDjAmSFTUms+wV/FbWBqi7fTJnjq3hj0XbQcd8hjj/q8d6ylgxCZSKi17y
# Vp2NL+cnT6Toy+rN+nM8M7LnLqCrO2JP3oW//1sfuZDKiDEb1AQ8es9Xr/u6bDTn
# YCTKIsDq1BtmXUqEG1NqzJKS4kOmxkYp2WyODi7vQTCBZtVFJfVZ3j7OgWmnhFr4
# yUozZtqgPrHRVHhGNKlYzyjlroPxul+bgIspzOwbtmsgY1MCAwEAAaOCAV0wggFZ
# MBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFO9vU0rp5AZ8esrikFb2L9RJ
# 7MtOMB8GA1UdIwQYMBaAFOzX44LScV1kTN8uZz/nupiuHA9PMA4GA1UdDwEB/wQE
# AwIBhjATBgNVHSUEDDAKBggrBgEFBQcDCDB3BggrBgEFBQcBAQRrMGkwJAYIKwYB
# BQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBBBggrBgEFBQcwAoY1aHR0
# cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0VHJ1c3RlZFJvb3RHNC5j
# cnQwQwYDVR0fBDwwOjA4oDagNIYyaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0Rp
# Z2lDZXJ0VHJ1c3RlZFJvb3RHNC5jcmwwIAYDVR0gBBkwFzAIBgZngQwBBAIwCwYJ
# YIZIAYb9bAcBMA0GCSqGSIb3DQEBCwUAA4ICAQAXzvsWgBz+Bz0RdnEwvb4LyLU0
# pn/N0IfFiBowf0/Dm1wGc/Do7oVMY2mhXZXjDNJQa8j00DNqhCT3t+s8G0iP5kvN
# 2n7Jd2E4/iEIUBO41P5F448rSYJ59Ib61eoalhnd6ywFLerycvZTAz40y8S4F3/a
# +Z1jEMK/DMm/axFSgoR8n6c3nuZB9BfBwAQYK9FHaoq2e26MHvVY9gCDA/JYsq7p
# GdogP8HRtrYfctSLANEBfHU16r3J05qX3kId+ZOczgj5kjatVB+NdADVZKON/gnZ
# ruMvNYY2o1f4MXRJDMdTSlOLh0HCn2cQLwQCqjFbqrXuvTPSegOOzr4EWj7PtspI
# HBldNE2K9i697cvaiIo2p61Ed2p8xMJb82Yosn0z4y25xUbI7GIN/TpVfHIqQ6Ku
# /qjTY6hc3hsXMrS+U0yy+GWqAXam4ToWd2UQ1KYT70kZjE4YtL8Pbzg0c1ugMZyZ
# Zd/BdHLiRu7hAWE6bTEm4XYRkA6Tl4KSFLFk43esaUeqGkH/wyW4N7OigizwJWeu
# kcyIPbAvjSabnf7+Pu0VrFgoiovRDiyx3zEdmcif/sYQsfch28bZeUz2rtY/9TCA
# 6TD8dC3JE3rYkrhLULy7Dc90G6e8BlqmyIjlgp2+VqsS9/wQD7yFylIz0scmbKvF
# oW2jNrbM1pD2T7m3XDCCBu0wggTVoAMCAQICEAqA7xhLjfEFgtHEdqeVdGgwDQYJ
# KoZIhvcNAQELBQAwaTELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDkRpZ2lDZXJ0LCBJ
# bmMuMUEwPwYDVQQDEzhEaWdpQ2VydCBUcnVzdGVkIEc0IFRpbWVTdGFtcGluZyBS
# U0E0MDk2IFNIQTI1NiAyMDI1IENBMTAeFw0yNTA2MDQwMDAwMDBaFw0zNjA5MDMy
# MzU5NTlaMGMxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjE7
# MDkGA1UEAxMyRGlnaUNlcnQgU0hBMjU2IFJTQTQwOTYgVGltZXN0YW1wIFJlc3Bv
# bmRlciAyMDI1IDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDQRqwt
# Esae0OquYFazK1e6b1H/hnAKAd/KN8wZQjBjMqiZ3xTWcfsLwOvRxUwXcGx8AUjn
# i6bz52fGTfr6PHRNv6T7zsf1Y/E3IU8kgNkeECqVQ+3bzWYesFtkepErvUSbf+EI
# YLkrLKd6qJnuzK8Vcn0DvbDMemQFoxQ2Dsw4vEjoT1FpS54dNApZfKY61HAldytx
# NM89PZXUP/5wWWURK+IfxiOg8W9lKMqzdIo7VA1R0V3Zp3DjjANwqAf4lEkTlCDQ
# 0/fKJLKLkzGBTpx6EYevvOi7XOc4zyh1uSqgr6UnbksIcFJqLbkIXIPbcNmA98Os
# kkkrvt6lPAw/p4oDSRZreiwB7x9ykrjS6GS3NR39iTTFS+ENTqW8m6THuOmHHjQN
# C3zbJ6nJ6SXiLSvw4Smz8U07hqF+8CTXaETkVWz0dVVZw7knh1WZXOLHgDvundrA
# tuvz0D3T+dYaNcwafsVCGZKUhQPL1naFKBy1p6llN3QgshRta6Eq4B40h5avMcpi
# 54wm0i2ePZD5pPIssoszQyF4//3DoK2O65Uck5Wggn8O2klETsJ7u8xEehGifgJY
# i+6I03UuT1j7FnrqVrOzaQoVJOeeStPeldYRNMmSF3voIgMFtNGh86w3ISHNm0Ia
# adCKCkUe2LnwJKa8TIlwCUNVwppwn4D3/Pt5pwIDAQABo4IBlTCCAZEwDAYDVR0T
# AQH/BAIwADAdBgNVHQ4EFgQU5Dv88jHt/f3X85FxYxlQQ89hjOgwHwYDVR0jBBgw
# FoAU729TSunkBnx6yuKQVvYv1Ensy04wDgYDVR0PAQH/BAQDAgeAMBYGA1UdJQEB
# /wQMMAoGCCsGAQUFBwMIMIGVBggrBgEFBQcBAQSBiDCBhTAkBggrBgEFBQcwAYYY
# aHR0cDovL29jc3AuZGlnaWNlcnQuY29tMF0GCCsGAQUFBzAChlFodHRwOi8vY2Fj
# ZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVzdGVkRzRUaW1lU3RhbXBpbmdS
# U0E0MDk2U0hBMjU2MjAyNUNBMS5jcnQwXwYDVR0fBFgwVjBUoFKgUIZOaHR0cDov
# L2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0VHJ1c3RlZEc0VGltZVN0YW1waW5n
# UlNBNDA5NlNIQTI1NjIwMjVDQTEuY3JsMCAGA1UdIAQZMBcwCAYGZ4EMAQQCMAsG
# CWCGSAGG/WwHATANBgkqhkiG9w0BAQsFAAOCAgEAZSqt8RwnBLmuYEHs0QhEnmNA
# ciH45PYiT9s1i6UKtW+FERp8FgXRGQ/YAavXzWjZhY+hIfP2JkQ38U+wtJPBVBaj
# YfrbIYG+Dui4I4PCvHpQuPqFgqp1PzC/ZRX4pvP/ciZmUnthfAEP1HShTrY+2DE5
# qjzvZs7JIIgt0GCFD9ktx0LxxtRQ7vllKluHWiKk6FxRPyUPxAAYH2Vy1lNM4kze
# kd8oEARzFAWgeW3az2xejEWLNN4eKGxDJ8WDl/FQUSntbjZ80FU3i54tpx5F/0Kr
# 15zW/mJAxZMVBrTE2oi0fcI8VMbtoRAmaaslNXdCG1+lqvP4FbrQ6IwSBXkZagHL
# hFU9HCrG/syTRLLhAezu/3Lr00GrJzPQFnCEH1Y58678IgmfORBPC1JKkYaEt2Od
# Dh4GmO0/5cHelAK2/gTlQJINqDr6JfwyYHXSd+V08X1JUPvB4ILfJdmL+66Gp3CS
# BXG6IwXMZUXBhtCyIaehr0XkBoDIGMUG1dUtwq1qmcwbdUfcSYCn+OwncVUXf53V
# JUNOaMWMts0VlRYxe5nK+At+DI96HAlXHAL5SlfYxJ7La54i71McVWRP66bW+yER
# NpbJCjyCYG2j+bdpxo/1Cy4uPcU3AWVPGrbn5PhDBf3Froguzzhk++ami+r3Qrx5
# bIbY3TVzgiFI7Gq3zWcxggU9MIIFOQIBATBhMFoxCzAJBgNVBAYTAlVTMRgwFgYD
# VQQKEw9VLlMuIEdvdmVybm1lbnQxDDAKBgNVBAsTA0RvRDEMMAoGA1UECxMDUEtJ
# MRUwEwYDVQQDEwxET0QgSUQgQ0EtNzICAxNh1TANBglghkgBZQMEAgEFAKCBhDAY
# BgorBgEEAYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3
# AgEEMBwGCisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMC8GCSqGSIb3DQEJBDEi
# BCAnarOLLJO637iQr7tmB5vjQ1Bp36D6YqQlAL+b+RMlGjANBgkqhkiG9w0BAQEF
# AASCAQB1VbITk0oSp33o9o1zc42xHmYU7MNYEFPk5y1X2dphY/+cIUvAt+Y4gumz
# MW+4HCujhzLFQBR3mrLchRPLFkspGIUyXGJ37U0IAyRHttHswVQr1cnb2Jsm39SP
# q5lr31YLTR4Sywtq/loI2KPB0XLJ1uCDCs9oMWIyAVEOwQTmrwSTCacqqyuh4GIm
# CoULSKXl/uH2U0GsV8t6E+4HrrWod07w4qeVokonleNpLixCqM3vpB8qkRne3yez
# i5lNpROJGS9CDx5R6Ij7oJNC1nCEyFaltCsO+ebe0g6Rf88d07V/DFEbh5tS0dli
# wNDgLeQjctump2gMh3wTKH7Z0rLloYIDJjCCAyIGCSqGSIb3DQEJBjGCAxMwggMP
# AgEBMH0waTELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDkRpZ2lDZXJ0LCBJbmMuMUEw
# PwYDVQQDEzhEaWdpQ2VydCBUcnVzdGVkIEc0IFRpbWVTdGFtcGluZyBSU0E0MDk2
# IFNIQTI1NiAyMDI1IENBMQIQCoDvGEuN8QWC0cR2p5V0aDANBglghkgBZQMEAgEF
# AKBpMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTI1
# MTExMjE3MTA1MlowLwYJKoZIhvcNAQkEMSIEIMMNkIadKkg5fMaZBguTCFzHT5UP
# KZIKLosHfducia4NMA0GCSqGSIb3DQEBAQUABIICAKUBKfScWz3UInY6CwojGEpN
# OCNkf6zU8ut9yWHgaOq3rSlyCiXcoHyefa4YZmwvNABUjFz3Z5u71R920PrHns0I
# 5mge8O95YvKOj10dArlpONcp/5HK6zrb510YyBmvvoPk8DBWpv5F3SvZM+KhoWZ4
# i3mF0jmsWfBQcNLMj0XKwn2K0TCO8bxP1UR//i5ZTikRIu+5gqCH/ivdE96e95CQ
# nnZviJ9ZY+AA2JZf6eCOBPhJOWyiRvNGv5Y7nhKpN1YGIZLAJyW+U/asWvetQtSe
# aIqKKqir86QzIOFay+wGCtjOkbt85UQ/y3KtSNeJFujWlbdVoMjErtjNJ1ymrjpQ
# EjYylLEo0/lfryjo3GUtDy13JoBMno2TIWK/qAvCCND5ahWKUbn4IvfCoZX/BtVY
# 6mTr+1S4843xkSrfJDuJ77SPc3/65mfwzG15vZUxGdgJYOBmlLklpGAf02Fw9KDn
# DIHmg3pAaoGXmE3PM9lzu+bT3cpXzzafkh1WEhhAicS5EjHURPRjxC4H3arBOYMs
# GcqOqQlTuvxMUvrXJ/zJVFZmwCpfv6m2NM2R2IIoCIfp+3zyX+eSSuJP5qrL3Cvi
# 1NT36gzIHePRJBcuK89KJ25j1PdyqdK8hvwmUuVkonL12QD0LETl8SQvDlzZsSis
# RIGarDLhppdpoI81VpaH
# SIG # End signature block
